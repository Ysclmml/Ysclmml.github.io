<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yscl的个人笔记</title>
  
  <subtitle>个人笔记</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-31T06:40:42.053Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yscl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/31/hello-world/"/>
    <id>http://example.com/2022/08/31/hello-world/</id>
    <published>2022-08-31T06:40:42.053Z</published>
    <updated>2022-08-31T06:40:42.053Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/08/31/go/ReadMe/"/>
    <id>http://example.com/2022/08/31/go/ReadMe/</id>
    <published>2022-08-31T06:40:29.657Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go-zero"><a href="#go-zero" class="headerlink" title="go-zero"></a>go-zero</h2><p>学习使用go-zero这个微服务框架, 并学习其中涉及到的许多知识. </p><ol><li><p>搭建环境</p></li><li><p>快速搭建官方微服务demo–短链服务</p></li><li><p>各个组件的学习<br>3.1   </p><p>3.2 </p><p>3.3 </p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;go-zero&quot;&gt;&lt;a href=&quot;#go-zero&quot; class=&quot;headerlink&quot; title=&quot;go-zero&quot;&gt;&lt;/a&gt;go-zero&lt;/h2&gt;&lt;p&gt;学习使用go-zero这个微服务框架, 并学习其中涉及到的许多知识. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>go网络编程</title>
    <link href="http://example.com/2021/07/08/go/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/07/08/go/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-07-07T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tcp编程"><a href="#Tcp编程" class="headerlink" title="Tcp编程"></a>Tcp编程</h2><p>go的net包封装的已经十分完善了,  基于tcp的socket编程也变得非常简单.</p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8200"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"listen fail, "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="comment">// 网络编程老一套, 接收连接的客户端, 等待处理</span></span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"accept failed"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">go</span> process(conn)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理过来的客户端的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> {</span><br><span class="line"><span class="comment">// 最后需要关闭连接</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">recv := bufio.NewReader(conn)</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">128</span>]<span class="type">byte</span></span><br><span class="line">n, err := recv.Read(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"recv from client err"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">}</span><br><span class="line">recvStr := <span class="type">string</span>(buf[:n])</span><br><span class="line">fmt.Println(<span class="string">"recv msg: "</span>, recvStr)</span><br><span class="line">conn.Write([]<span class="type">byte</span>(recvStr))  <span class="comment">// 发送数据, 相当于echo</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8200"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"连接服务端失败"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">input, _ := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">inputInfo := strings.Trim(input, <span class="string">"\r\n"</span>)</span><br><span class="line"><span class="keyword">if</span> strings.ToUpper(inputInfo) == <span class="string">"Q"</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">_, err = conn.Write([]<span class="type">byte</span>(inputInfo))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">buf := [<span class="number">512</span>]<span class="type">byte</span>{}</span><br><span class="line">n, err := conn.Read(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">fmt.Println(<span class="string">"recv error "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="type">string</span>(buf[:n]))</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> {</span><br><span class="line">fmt.Println(r.RemoteAddr, <span class="string">"连接成功"</span>)</span><br><span class="line">fmt.Println(<span class="string">"http方法: "</span>, r.Method)</span><br><span class="line">fmt.Println(<span class="string">"url:"</span>, r.URL)</span><br><span class="line">fmt.Println(<span class="string">"header:"</span>, r.Header)</span><br><span class="line">fmt.Println(<span class="string">"body"</span>, r.Body)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">"&lt;h1&gt;hello world!!!&lt;/h1&gt;\n"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, MyHandler)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">go网络编程</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go基础" scheme="http://example.com/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go语法总结</title>
    <link href="http://example.com/2021/07/02/go/%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/07/02/go/%E5%9F%BA%E7%A1%80/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-01T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th align="left">类型</th><th align="left">长度(字节)</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">1</td><td align="left">false</td><td align="left"></td></tr><tr><td align="left">byte</td><td align="left">1</td><td align="left">0</td><td align="left">uint8</td></tr><tr><td align="left">rune</td><td align="left">4</td><td align="left">0</td><td align="left">Unicode Code Point, int32</td></tr><tr><td align="left">int, uint</td><td align="left">4或8</td><td align="left">0</td><td align="left">32 或 64 位</td></tr><tr><td align="left">int8, uint8</td><td align="left">1</td><td align="left">0</td><td align="left">-128 ~ 127, 0 ~ 255，byte是uint8 的别名</td></tr><tr><td align="left">int16, uint16</td><td align="left">2</td><td align="left">0</td><td align="left">-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td align="left">int32, uint32</td><td align="left">4</td><td align="left">0</td><td align="left">-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td align="left">int64, uint64</td><td align="left">8</td><td align="left">0</td><td align="left"></td></tr><tr><td align="left">float32</td><td align="left">4</td><td align="left">0.0</td><td align="left"></td></tr><tr><td align="left">float64</td><td align="left">8</td><td align="left">0.0</td><td align="left"></td></tr><tr><td align="left">complex64</td><td align="left">8</td><td align="left"></td><td align="left">复数, 如1+3i, -1i , 实部和虚部为32位</td></tr><tr><td align="left">complex128</td><td align="left">16</td><td align="left"></td><td align="left">实部和虚部为64位</td></tr><tr><td align="left">uintptr</td><td align="left">4或8</td><td align="left"></td><td align="left">以存储指针的 uint32 或 uint64 整数</td></tr><tr><td align="left">array</td><td align="left"></td><td align="left"></td><td align="left">值类型</td></tr><tr><td align="left">struct</td><td align="left"></td><td align="left"></td><td align="left">值类型</td></tr><tr><td align="left">string</td><td align="left"></td><td align="left">“”</td><td align="left">UTF-8 字符串</td></tr><tr><td align="left">slice</td><td align="left"></td><td align="left">nil</td><td align="left">引用类型</td></tr><tr><td align="left">map</td><td align="left"></td><td align="left">nil</td><td align="left">引用类型</td></tr><tr><td align="left">channel</td><td align="left"></td><td align="left">nil</td><td align="left">引用类型</td></tr><tr><td align="left">interface</td><td align="left"></td><td align="left">nil</td><td align="left">接口</td></tr><tr><td align="left">function</td><td align="left"></td><td align="left">nil</td><td align="left">函数</td></tr></tbody></table><p>上面是go的基础类型, 没啥好多说的, 不过还是有几个需要注意的地方.</p><div class="note warning simple"><ul><li>int类型和操作系统有关, 32位机器上是4个字节长度的有符号整型, 64位机器是8个字节的有符号整型. int和unit与 int8,int16不是一个类型. </li><li>byte是unit8的别名, rune是int32的别名, 这两者是等价的. </li><li>struct和array都是值类型, slice才是引用类型</li></ul></div><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是<code>go</code>语言的常量计数器，只能在常量的表达式中使用。 <code>iota</code>在<code>const</code>关键字出现时将被重置为<code>0</code>。<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次(<span class="p red">iota可理解为const语句块中的行索引</span>)。 使用<code>iota</code>能简化定义，在定义枚举时很有用。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试常量</span></span><br><span class="line"><span class="comment">// const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br><span class="line">fmt.Println(KB, PB)</span><br></pre></td></tr></tbody></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点型与整型的互转</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">6.4</span></span><br><span class="line">fmt.Println(<span class="type">int</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">// []byte/rune类型和字符串类型的转换</span></span><br><span class="line">d := <span class="string">"中国"</span></span><br><span class="line">e := []<span class="type">byte</span>(d)</span><br><span class="line">f := []<span class="type">byte</span>(d)</span><br><span class="line">fmt.Println(d, e, f)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组转切片</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">8</span>]<span class="type">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}</span><br><span class="line"><span class="keyword">var</span> b []<span class="type">int</span></span><br><span class="line">b = a[:]</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// string转int Atoi 等价于 ParseInt(s, 10, 0)</span></span><br><span class="line">i, _ := strconv.Atoi(<span class="string">"12345"</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// string转int64, 第二个参数是进制, 第三个参数是返回的位数, 0为int 8, 32, 64对应int8, int32...</span></span><br><span class="line"><span class="comment">// 报名记法就是str + convert的缩写</span></span><br><span class="line">i2, _ := strconv.ParseInt(<span class="string">"7"</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">"i2"</span>, i2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// int64转字符串</span></span><br><span class="line">s := strconv.FormatInt(<span class="number">65</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// int转字符串, 相当于上面的一个简写</span></span><br><span class="line">s = strconv.Itoa(<span class="number">12</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// float转字符串</span></span><br><span class="line">s = strconv.FormatFloat(<span class="number">1.2456</span>, <span class="string">'E'</span>, <span class="number">-5</span>, <span class="number">64</span>) <span class="comment">// -&gt; 1.2456E+00</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">s = strconv.FormatFloat(<span class="number">1.2456</span>, <span class="string">'f'</span>, <span class="number">-5</span>, <span class="number">64</span>) <span class="comment">// -&gt; 1.2456</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个字节转字符串</span></span><br><span class="line">chr := <span class="string">'a'</span></span><br><span class="line">fmt.Println(<span class="type">string</span>([]<span class="type">rune</span>{chr}))</span><br><span class="line"><span class="comment">// 转换的另一种方式</span></span><br><span class="line"><span class="keyword">var</span> cc <span class="type">byte</span> = <span class="string">'a'</span></span><br><span class="line">s = fmt.Sprintf(<span class="string">"%c"</span>, cc)</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure><div class="btns rounded grid5">            <a class="button" href="https://golang.org/pkg/strconv/" title="官网文档 strconv包"><i class="fas fa-book-open"></i>官网文档 strconv包</a>          </div><h3 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改"></a>字符串修改</h3><p>go里的字符串是可变的, 需要先转换成字节数组, 再进行转换</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"我爱我家"</span></span><br><span class="line">b := []<span class="type">rune</span>(s)</span><br><span class="line">b[<span class="number">3</span>] = <span class="string">'变'</span></span><br><span class="line">s = <span class="type">string</span>(b)</span><br><span class="line">fmt.Println(s)</span><br></pre></td></tr></tbody></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><div class="note default flat"><ol><li>数组：是同一种数据类型的固定长度的序列。</li><li>数组定义：var a [len]int，比如：var a [5]int，数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。</li><li>长度是数组类型的一部分，因此，var a[5] int和var a[10]int是不同的类型。</li><li>数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1<br>for i := 0; i &lt; len(a); i++ {}<br>for index, v := range a {}</li><li>访问越界，如果下标在数组合法范围之外，则触发访问越界，会panic</li><li>数组是值类型，赋值和传参会复制整个数组，而不是指针。因此改变副本的值，不会改变本身的值。<br>7.支持 “==”、”!=” 操作符，因为内存总是被初始化过的。<br>8.指针数组 [n]*T，数组指针 *[n]T</li></ol></div><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ {</span><br><span class="line">fmt.Print(a[i], <span class="string">" "</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> a {</span><br><span class="line">fmt.Println(i, val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义初始化</span></span><br><span class="line">b := [<span class="number">3</span>]<span class="type">string</span>{<span class="string">"aaa"</span>, <span class="string">"bbb"</span>}</span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动根据后面初始化的个数来确定长度, 使用:指定索引初始化</span></span><br><span class="line">data := [...]<span class="type">int</span>{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>: <span class="number">0</span>}</span><br><span class="line">fmt.Println(data)  <span class="comment">// -&gt; [0 1 2 3 4 0 0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组的定义与初始化</span></span><br><span class="line">c := [<span class="number">3</span>][<span class="number">3</span>]<span class="type">int</span>{{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, {<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}, {<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>}}</span><br><span class="line">fmt.Println(c)</span><br><span class="line"><span class="keyword">for</span> _, row := <span class="keyword">range</span> c {</span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> row {</span><br><span class="line">fmt.Print(val, <span class="string">" "</span>)</span><br><span class="line">}</span><br><span class="line">fmt.Println()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组可以使用比较运算符 == != </span></span><br><span class="line">d := [<span class="number">3</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">e := [<span class="number">3</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">f := [<span class="number">3</span>]<span class="type">int</span>{<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>}</span><br><span class="line">fmt.Println(d == e, e== f)  <span class="comment">// -&gt; true false</span></span><br></pre></td></tr></tbody></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><div class="note success flat"><ol><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片是一个可变的数组。</li><li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </li><li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</li><li>切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。</li><li>如果 slice == nil，那么 len、cap 结果都等于 0。</li></ol></div><h3 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h3><p>通过make创建时, 需要指定切片的长度, 也可以指定第三个参数, 切片底层数组的长度, 也是切片的cap数量. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片声明</span></span><br><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line">fmt.Println(s1 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不指定长度就是切片, 定义并初始化</span></span><br><span class="line">s2 := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// make创建</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(s3, s4)</span><br></pre></td></tr></tbody></table></figure><h3 id="从数组中获取"><a href="#从数组中获取" class="headerlink" title="从数组中获取"></a>从数组中获取</h3><p>go的这种取法和Python列表的切片方式一模一样,  左开右闭. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中获取</span></span><br><span class="line">arr := [<span class="number">8</span>]<span class="type">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>}</span><br><span class="line"><span class="comment">// 省略左边表示从0开始取, 省略右边表示取到结尾</span></span><br><span class="line">s5 := arr[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">s6 := arr[:]</span><br><span class="line">s7 := arr[:<span class="number">5</span>]</span><br><span class="line">s8 := arr[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(s6, s7, s8)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然也可以直接从切片本身 切</span></span><br><span class="line">fmt.Println(s5[<span class="number">0</span>:<span class="number">2</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片的其他操作</span></span><br><span class="line"><span class="comment">// 切片是引用类型</span></span><br><span class="line">arr := [<span class="number">8</span>]<span class="type">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>}</span><br><span class="line">s1 := arr[:]</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩充切片</span></span><br><span class="line">s2 := []<span class="type">int</span>{<span class="number">0</span>, <span class="number">0</span>}</span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片的复制, 可以指定将源切片复制到目标切片的指定位置.</span></span><br><span class="line">s4 := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>}</span><br><span class="line">s3 := []<span class="type">int</span>{<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>}</span><br><span class="line">n := <span class="built_in">copy</span>(s4[<span class="number">3</span>:<span class="number">5</span>], s3)</span><br><span class="line">fmt.Println(n)</span><br><span class="line">fmt.Println(s4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片的索引操作是可以取超出本身长度的, 但是不能超过其capacity</span></span><br><span class="line"><span class="keyword">var</span> a = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">fmt.Printf(<span class="string">"slice a : %v , len(a) : %v\n"</span>, a, <span class="built_in">len</span>(a))</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">fmt.Printf(<span class="string">"slice b : %v , len(b) : %v, cap(c) : %v\n"</span>, b, <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line">c := b[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">"slice c : %v , len(c) : %v, cap(c) : %v\n"</span>, c, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(b))</span><br><span class="line"></span><br><span class="line">d := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(d), <span class="built_in">cap</span>(d))</span><br><span class="line"><span class="built_in">copy</span>(d, []<span class="type">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>})</span><br><span class="line">fmt.Println(d)</span><br><span class="line">fmt.Println(d[<span class="number">2</span>:<span class="number">6</span>])</span><br></pre></td></tr></tbody></table></figure><div class="note warning flat"><p>切片有len和cap两个属性, 切片本身重新resize的时候是可以超出自己len边界的,但是不可以超出cap</p></div><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>map就是字典类型的数据结构, 比较简单, 不多做说明</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map定义可以指定数量, 也可以不指定具体数量</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值, 和Python里面一样</span></span><br><span class="line">m[<span class="string">"a"</span>] = <span class="string">"aaa"</span></span><br><span class="line">m[<span class="string">"b"</span>] = <span class="string">"bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在某key</span></span><br><span class="line"><span class="keyword">if</span> val, ok := m[<span class="string">"a"</span>]; ok {</span><br><span class="line">fmt.Println(val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> m {</span><br><span class="line">fmt.Println(key, val)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"a"</span>)</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"aaaaaaaaa"</span>)</span><br><span class="line">fmt.Println(<span class="string">"=============="</span>)</span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> m {</span><br><span class="line">fmt.Println(key, val)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>一个和map相关的面试题</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> {</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*student)</span><br><span class="line">stus := []student{</span><br><span class="line">{name: <span class="string">"pprof.cn"</span>, age: <span class="number">18</span>},</span><br><span class="line">{name: <span class="string">"测试"</span>, age: <span class="number">23</span>},</span><br><span class="line">{name: <span class="string">"博客"</span>, age: <span class="number">28</span>},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus {</span><br><span class="line">m2[stu.name] = &amp;stu</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m2 {</span><br><span class="line">fmt.Println(k, <span class="string">"=&gt;"</span>, v.name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面结果比较出乎意料, 打印出来的name都是同一个. </p><div class="tip cogs"><p>原因其实也比较好理解, 因为结构体在go里面是值类型.  for range循环遍历结构体切片的时候每次将结构体copy临时变量, 最后map中保存的其实都是for循环的那个变量的地址, 而不是切片内包含的结构体地址.</p></div><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><p>结构体可以模拟出面向对象编程的封装的特性(<span class="p green">将属性和方法封装起来</span>). </p><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><p>结构体定义的格式比较简单.</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> {</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note default flat"><ol><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ol></div><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) {</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><div class="note default flat"><ol><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。如果是指针类型, 对变量的修改会影响外部调用方, 否则只是对接受者副本的修改, 不影响调用方的内部数据. </li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ol></div><div class="tip cogs"><p>什么时候应该使用指针类型接收者</p><ul><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ul></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><div class="note default flat"><p>go里面的函数有以下特点</p><ul><li>无需声明原型。</li><li>支持不定 变参。</li><li>支持多返回值。</li><li>命名返回参数。 </li><li>支持匿名函数和闭包。</li><li>函数也是一种类型，一个函数可以赋值给变量。</li><li>不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。</li><li>不支持 重载 (overload) </li><li>不支持 默认参数 (default parameter)。</li></ul></div><p>go的标准函数定义示例, 展现了go函数的部分特点.</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(num ...<span class="type">int</span>)</span></span> (sum, count <span class="type">int</span>) {</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> num {</span><br><span class="line">sum += n</span><br><span class="line">}</span><br><span class="line">count = <span class="built_in">len</span>(num)</span><br><span class="line"><span class="keyword">return</span> sum, count</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。</p><p>“官方”的解释是：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>个人理解就是, 一般闭包是在嵌套函数中出现的, 这个外层函数定义了一些变量, 然后函数返回值是内层函数的引用(函数名), 并且内层函数还引用了外层函数的变量. 这个内层函数和外层函数的变量统一称为一个闭包. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumWithInitial</span><span class="params">(initial <span class="type">int</span>)</span></span> SumFunc {</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(num ...<span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">sum := initial</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> num {</span><br><span class="line">sum += n</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    f := SumWithInitial(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p><strong>defer特性</strong></p><div class="note primary flat"><ol><li>关键字 defer 用于注册延迟调用。</li><li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li><li>多个defer语句，按先进后出的方式执行。</li><li>defer语句中的变量，在defer声明时就决定了。</li></ol></div><p><strong>defer用途</strong></p><div class="note success flat"><ol><li>关闭文件句柄</li><li>锁资源释放</li><li>数据库连接释放</li></ol></div><p>一个容易出错的使用例子</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tDefer</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> whatever [<span class="number">5</span>]<span class="keyword">struct</span>{}</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> whatever {</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { fmt.Println(i) }()</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出都为4. defer是延迟调用的, 先前只会保存现场, 最后调用的时候i变量为4</p><p>稍微修改一下就能符合预期.</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> whatever {</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(k <span class="type">int</span>)</span></span> { fmt.Println(k) }(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">go反射</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go基础" scheme="http://example.com/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go反射总结</title>
    <link href="http://example.com/2021/05/11/go/%E5%9F%BA%E7%A1%80/go%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2021/05/11/go/%E5%9F%BA%E7%A1%80/go%E5%8F%8D%E5%B0%84/</id>
    <published>2021-05-10T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go反射总结"><a href="#Go反射总结" class="headerlink" title="Go反射总结"></a>Go反射总结</h2><p>Go 语言中反射的操作主要定义在标准库 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 中，在标准库中定义了两种类型来表现运行时的对象信息，分别是：<a href="https://golang.org/pkg/reflect/#Value"><code>reflect.Value</code></a>（反射对象的值信息）和 <a href="https://golang.org/pkg/reflect/#Type"><code>reflect.Type</code></a>（反射对象的类型信息），Go 语言中所有反射操作都是基于这两个类型进行的。</p><h3 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h3><p>下面所有反射操作都是基于下面结构体进行的. </p><p>定义了一个User结构体, 并且包含一个方法. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>{</span><br><span class="line">Id <span class="type">int64</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`form:"name" json:"name" binding:"required,gte=5" message:"required:用户名不能为空"`</span></span><br><span class="line">Age <span class="type">uint8</span> <span class="string">`form:"age" json:"age" binding:"required,lt=10" message:"required:年龄不能为空|lt:年龄必须小于10"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> GetName() <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User: "</span> + u.Name</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-Value与Type"><a href="#1-Value与Type" class="headerlink" title="1. Value与Type"></a>1. Value与Type</h3><p>前面说过reflect包提供了2个对象来描述go语言运行时的对象状态信息.  那么首先就需要通过reflect包提供的两个基础方法<code>reflect.ValueOf()</code> 和 <code>reflect.TypeOf()</code>来获取到这两个对象.</p><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">fmt.Println(v)  <span class="comment">// 输出: {1 tom 20}</span></span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">fmt.Println(t)  <span class="comment">// 输出: main.User</span></span><br></pre></td></tr></tbody></table></figure><p>根据基础的打印信息, 可以看出已经知道了u对象的值及其类型信息.  接下来就是需要指导这个对象内更具体的信息. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Type(), t, v.Type() == t) <span class="comment">// main.User main.User true</span></span><br></pre></td></tr></tbody></table></figure><p>type和value可以互相转换</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Type(), t, v.Type() == t) <span class="comment">// main.User main.User true</span></span><br><span class="line">fmt.Println(reflect.New(t))  <span class="comment">// &amp;{0  0}</span></span><br></pre></td></tr></tbody></table></figure><p>通过<code>v.Type()</code>方法可以获取到value对象, 通过<code>relect</code>包的New方法可以获取到Type对象所对应的零值对象. </p><h3 id="2-Kind"><a href="#2-Kind" class="headerlink" title="2. Kind"></a>2. Kind</h3><p><code>Kind</code> 表示反射对象的类型 <code>Type</code> 所代表的具体类型，零值表示无效的类型，下面是<code>reflect</code>包预定义的Kind</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Invalid Kind = <span class="literal">iota</span></span><br><span class="line">Bool</span><br><span class="line">Int</span><br><span class="line">Int8</span><br><span class="line">Int16</span><br><span class="line">Int32</span><br><span class="line">Int64</span><br><span class="line">Uint</span><br><span class="line">Uint8</span><br><span class="line">Uint16</span><br><span class="line">Uint32</span><br><span class="line">Uint64</span><br><span class="line">Uintptr</span><br><span class="line">Float32</span><br><span class="line">Float64</span><br><span class="line">Complex64</span><br><span class="line">Complex128</span><br><span class="line">Array</span><br><span class="line">Chan</span><br><span class="line">Func</span><br><span class="line">Interface</span><br><span class="line">Map</span><br><span class="line">Ptr</span><br><span class="line">Slice</span><br><span class="line">String</span><br><span class="line">Struct</span><br><span class="line">UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>上面的Value和Type对象都有Kind()方法来获取对应的真实类型</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Kind())  <span class="comment">// struct</span></span><br><span class="line">fmt.Println(t.Kind())  <span class="comment">// struct</span></span><br></pre></td></tr></tbody></table></figure><p>通过Type对象和Value对象获取到的Kind可以看到都是<code>struct</code>类型</p><h3 id="3-反射对象的字段"><a href="#3-反射对象的字段" class="headerlink" title="3. 反射对象的字段"></a>3. 反射对象的字段</h3><p><strong>首先需要说明, 这里所说的对象一般都是指代结构体(<code>struct</code>)对象.</strong> </p><p>使用反射一般来说是需要获取到反射的对象的字段信息.  </p><h4 id="NumField"><a href="#NumField" class="headerlink" title="NumField"></a><code>NumField</code></h4><p>Value对象和Type对象都有<code>NumField</code>这个方法来获取到结构体对象的字段数量</p><p>使用这个方法必须要求被反射的原始对象必须为结构体, 即使是一个指向结构体对象的指针也会panic错误. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">fmt.Println(reflect.ValueOf(u).NumField())   <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a><code>Field</code></h4><p>获取到了数量之后, 可以通过for循环来遍历所有字段, 使用Field(i)方法来获取到对应的字段信息. </p><p>Type对象获取到的对应的字段是结构体对象定义的元信息, 如tag信息, 字段名字, 字段类型等…</p><p>Value对象获取到的是对应字段的值</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line"><span class="comment">// fmt.Println(reflect.ValueOf(u).NumField())</span></span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">typeField := t.Field(i)</span><br><span class="line">valueField := v.Field(i)</span><br><span class="line">fmt.Println(<span class="string">"typeField"</span>, typeField)</span><br><span class="line">fmt.Println(<span class="string">"valueField"</span>, valueField)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后输出如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeField {Id  <span class="type">int64</span>  <span class="number">0</span> [<span class="number">0</span>] <span class="literal">false</span>}</span><br><span class="line">valueField <span class="number">1</span></span><br><span class="line">typeField {Name  <span class="type">string</span> form:<span class="string">"name"</span> json:<span class="string">"name"</span> binding:<span class="string">"required,gte=5"</span> message:<span class="string">"required:用户名不能为空"</span> <span class="number">8</span> [<span class="number">1</span>] <span class="literal">false</span>}</span><br><span class="line">valueField tom</span><br><span class="line">typeField {Age  <span class="type">uint8</span> form:<span class="string">"age"</span> json:<span class="string">"age"</span> binding:<span class="string">"required,lt=10"</span> message:<span class="string">"required:年龄不能为空|lt:年龄必须小于10"</span> <span class="number">24</span> [<span class="number">2</span>] <span class="literal">false</span>}</span><br><span class="line">valueField <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到<code>typeField</code>输出了结构体定义时的完整的信息</p><p>这个<code>typefield</code>是<code>StructField</code>类型, 在reflect包中定义如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> {</span><br><span class="line"><span class="comment">// Name is the field name.</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line"><span class="comment">// PkgPath is the package path that qualifies a lower case (unexported)</span></span><br><span class="line"><span class="comment">// field name. It is empty for upper case (exported) field names.</span></span><br><span class="line"><span class="comment">// See https://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">PkgPath <span class="type">string</span></span><br><span class="line"></span><br><span class="line">Type      Type      <span class="comment">// field type</span></span><br><span class="line">Tag       StructTag <span class="comment">// field tag string</span></span><br><span class="line">Offset    <span class="type">uintptr</span>   <span class="comment">// offset within struct, in bytes</span></span><br><span class="line">Index     []<span class="type">int</span>     <span class="comment">// index sequence for Type.FieldByIndex</span></span><br><span class="line">Anonymous <span class="type">bool</span>      <span class="comment">// is an embedded field</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>主要关注Tag, Name, Type参数分别是字段的tag, 名字及其类型, 利用这几个参数就尤其是可以通过tag来实现很多自动化的工作了.  如gin框架中的校验器使用的<code>validate </code>tag以及序列化所使用到的<code>json </code>tag都是利用反射获取tag信息来完成的. </p><p>上面的<code>valueField</code>返回的还是一个Value对象, 通过这个Value对象可以获取每个字段的值, 如果字段仍然是<code>struct</code>类型, 那么可以继续递归操作. </p><h3 id="4-Elem"><a href="#4-Elem" class="headerlink" title="4. Elem"></a>4. Elem</h3><p><code>Elem()</code> 方法定义：<code>func (v Value) Elem() Value</code>，返回 <code>v</code> 包含的值或指针 <code>v</code> 指向的值，<code>v</code> 的 <code>Kind</code> 如果不是 <code>Interface</code> 或 <code>Ptr</code>，则会 panic. Elem方法等效于对指针类型变量做了一个<code>*</code>操作, 不过这个也有不同的地方. </p><p>当需要对反射的对象做修改操作时, 就必须用到Elem方法.  举一个demo. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">fmt.Println(<span class="string">"before u: ...."</span>, u)</span><br><span class="line">elem := reflect.ValueOf(&amp;u).Elem()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; elem.NumField(); i++ {</span><br><span class="line">eleField := elem.Field(i)</span><br><span class="line"><span class="keyword">if</span> eleField.CanSet() {</span><br><span class="line"><span class="keyword">if</span> eleField.Kind() == reflect.String {</span><br><span class="line">eleField.SetString(<span class="string">"修改后String"</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> eleField.Kind() == reflect.Int {</span><br><span class="line">eleField.SetInt(<span class="number">333333</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> eleField.Kind() == reflect.Int64 {</span><br><span class="line">eleField.SetInt(<span class="number">6666666</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"after u: ...."</span>, u)</span><br></pre></td></tr></tbody></table></figure><p>输出结果</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before u: .... {<span class="number">1</span> tom <span class="number">20</span>}</span><br><span class="line">after u: .... {<span class="number">6666666</span> 修改后String <span class="number">20</span>}</span><br></pre></td></tr></tbody></table></figure><p>上面使用到了<code>CanSet</code>方法, 这个是只有使用elem方法获取到field才会返回True, 才可以做后面的修改值操作. </p><p>总而言之, elem方法其实就是相当于对获取到的字段做了一次取指针操作, 与直接使用没有太大的区别. </p><h3 id="5-反射对象的方法"><a href="#5-反射对象的方法" class="headerlink" title="5. 反射对象的方法"></a>5. 反射对象的方法</h3><p>获取方法对象和获取属性很类似, 使用方法都在下面的注释说明了.  不过里面需要注意的是方法入参还把接收对象也当做入参参数之一了. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ {</span><br><span class="line">method := t.Method(i)  <span class="comment">// 返回方法结构体</span></span><br><span class="line">vMethod := v.Method(i)</span><br><span class="line">mt := method.Type</span><br><span class="line">fmt.Println(method, vMethod, <span class="string">"====="</span>, method.Type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取入参参数, 结构体对象的方法, 获取的方法信息对象会把方法的接受者也当着入参之一</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; mt.NumIn(); j++ {</span><br><span class="line">in := mt.In(j)</span><br><span class="line">fmt.Println(<span class="string">"in ......."</span>, in, in.Name(), in.Kind())  <span class="comment">// in ....... main.User User struct</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法返回类型</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; mt.NumOut(); j++ {</span><br><span class="line">fmt.Println(<span class="string">"method out type:"</span>, mt.Out(j))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的调用</span></span><br><span class="line"><span class="keyword">if</span> method.Name == <span class="string">"SetName"</span> {</span><br><span class="line"><span class="comment">// 这里需要组织入参参数, 都是value类型的, 需要注意要传接收对象</span></span><br><span class="line">ins := []reflect.Value{reflect.ValueOf(u), reflect.ValueOf(<span class="string">"反射调用方法值"</span>)}</span><br><span class="line">method.Func.Call(ins)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6. 其他方法"></a>6. 其他方法</h3><p><code>FieldByName</code> 直接通过名字获取到对应的字段信息</p><p><code>MethodByName</code> 直接通过方法名字获取到对应的方法结构体</p><p>上面两种方式获取到结构体对象与遍历Field(index)的效果是一样的. 具体使用哪种看需求. </p><p><code>Interface</code> 是value对象的方法. 通过这个interface可还原取到value对象的原始值</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">if</span> name, exist := t.FieldByName(<span class="string">"Name"</span>); exist {</span><br><span class="line">fmt.Println(name.Name, name.Tag)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> fun, exist := t.MethodByName(<span class="string">"SetName"</span>); exist {</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">ins := []reflect.Value{reflect.ValueOf(u), reflect.ValueOf(<span class="string">"反射调用方法值"</span>)}</span><br><span class="line">fun.Func.Call(ins)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用Interface方法还原对象</span></span><br><span class="line"><span class="keyword">if</span> u1, ok := v.Interface().(User); ok {</span><br><span class="line">fmt.Println(<span class="string">"after:"</span>, u1.Name, u1.Age)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><ul><li><a href="https://ehlxr.me/2018/01/26/golang-reflect/">Golang 反射使用总结</a></li><li><a href="https://golang.org/pkg/reflect/#Type">官方文档</a></li></ul>]]></content>
    
    
    <summary type="html">go反射</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go基础" scheme="http://example.com/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>基于go-zero框架搭建短链服务Demo</title>
    <link href="http://example.com/2021/04/30/go/2-shortcut/"/>
    <id>http://example.com/2021/04/30/go/2-shortcut/</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据go-zero官方的demo示例, 尝试搭建一个shorturl短链服务.</p><h2 id="搭建短链服务"><a href="#搭建短链服务" class="headerlink" title="搭建短链服务"></a>搭建短链服务</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>整个服务叫做短链服务, 项目名称就叫做shorturl, 然后需要在里面创建两个文件夹<code>api</code>和<code>rpc</code>. </p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module shorturl</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/antlr/antlr4 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210412152734</span>-e404d26f6142 <span class="comment">// indirect</span></span><br><span class="line">github.com/<span class="keyword">go</span>-sql-driver/mysql v1<span class="number">.6</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/golang/protobuf v1<span class="number">.4</span><span class="number">.2</span></span><br><span class="line">github.com/iancoleman/strcase v0<span class="number">.1</span><span class="number">.3</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/tal-tech/<span class="keyword">go</span>-zero v1<span class="number">.1</span><span class="number">.6</span></span><br><span class="line"><span class="keyword">go</span>.uber.org/automaxprocs v1<span class="number">.4</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">google.golang.org/grpc v1<span class="number">.29</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h3 id="编写api服务"><a href="#编写api服务" class="headerlink" title="编写api服务"></a>编写api服务</h3><p>既然是做微服务demo, 那么最重要的就是编写api网关相关的代码了, 这相当于微服务的大脑. 根据官方文档, 首先需要使用goctl工具创建api的模板代码.  </p><h4 id="编写api文件"><a href="#编写api文件" class="headerlink" title="编写api文件"></a>编写api文件</h4><p>进入到api文件夹下,  使用<code>goctl api -o shorturl.api</code>命令, 会在当前目录下创建出一个<code>shorturl.api</code>的模板文件, 接下来需要对这个文件进行编辑. </p><p>先不用管文件内的info相关信息, 直接去除. 然后就可以像go的编码习惯一样, 先定义变量(传输用的结构体) , 然后编写接口函数(这里叫做定义服务). </p><blockquote><p>因为是短链服务,  两个基础功能是必须的, 一个是根据原始url返回缩短后的url,  一个是根据缩短后的url去查原始url. 由这两个功能, 需要定义的数据传输的结构体就容易了. </p></blockquote><p>整体代码如下所示</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"v1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义根据短链查原始链接的请求与响应的相关结构体</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">expandReq {</span><br><span class="line">shorten <span class="type">string</span> <span class="string">`form:shorten`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">expandResp {</span><br><span class="line">url <span class="type">string</span> <span class="string">`json:url`</span></span><br><span class="line">}</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义根据长链缩短原始链接的相关结构体</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">shortenReq {</span><br><span class="line">url <span class="type">string</span> <span class="string">`from:url`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">shortenResp {</span><br><span class="line">shorten <span class="type">string</span> <span class="string">`json:shorten`</span></span><br><span class="line">}</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个shorturl的服务, 名字叫做shorturl-api</span></span><br><span class="line"><span class="comment">// 主要定义两个接口功能, 一个用来缩短原始长链, 一个用来根据短链来查原始链接</span></span><br><span class="line">service shorturl-api {</span><br><span class="line"><span class="comment">// 定义server需要用到的相关属性</span></span><br><span class="line">@server (</span><br><span class="line">handler: shortenHandler</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义url, 参数就是上面定义到的结构体, 返回信息也在上面进行了定义</span></span><br><span class="line">get /shorten(shortenReq) returns(shortenResp)</span><br><span class="line"></span><br><span class="line">@server (</span><br><span class="line">handler: expandHandler</span><br><span class="line">)</span><br><span class="line">get /expand(expandReq) returns(expandResp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单对上面的代码进行说明</p><ul><li>type和go一样进行结构体的声明</li><li>service shorturl-api表示定义一个叫shorturl-api的服务, 里面会定义这个服务相关的http请求方法</li><li>@server部分用来定义 server 端用到的属性</li></ul><ul><li><code>handler</code> 定义了服务端 handler 名字</li><li><code>get /shorten(shortenReq) returns(shortenResp)</code> 定义了 get 方法的路由、请求参数、返回参数等</li></ul><h4 id="生成api网关代码"><a href="#生成api网关代码" class="headerlink" title="生成api网关代码"></a>生成api网关代码</h4><p>使用goctl工具生成api gateway代码, 同样在api目录下使用<code> goctl api go -api shorturl.api -dir .</code>命令生成api网关相关的代码. </p><p>大致目录如下所示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   ├── etc</span><br><span class="line">│   │   └── shorturl-api.yaml         // 配置文件</span><br><span class="line">│   ├── internal</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   │   └── config.go             // 定义配置</span><br><span class="line">│   │   ├── handler</span><br><span class="line">│   │   │   ├── expandhandler.go      // 实现 expandHandler</span><br><span class="line">│   │   │   ├── routes.go             // 定义路由处理</span><br><span class="line">│   │   │   └── shortenhandler.go     // 实现 shortenHandler</span><br><span class="line">│   │   ├── logic</span><br><span class="line">│   │   │   ├── expandlogic.go        // 实现 ExpandLogic</span><br><span class="line">│   │   │   └── shortenlogic.go       // 实现 ShortenLogic</span><br><span class="line">│   │   ├── svc</span><br><span class="line">│   │   │   └── servicecontext.go     // 定义 ServiceContext</span><br><span class="line">│   │   └── types</span><br><span class="line">│   │       └── types.go              // 定义请求、返回结构体</span><br><span class="line">│   ├── shorturl.api</span><br><span class="line">│   └── shorturl.go                   // main 入口定义</span><br></pre></td></tr></tbody></table></figure><p>到这其实就已经可以启动api网关了, 默认的监听端口为8888</p><p><code>go run shorturl.go -f etc/shorturl-api.yaml</code></p><p>终端会打印出<code>Starting server at 0.0.0.0:8888...</code>的log消息, 说明到目前为止, 环境配的没啥问题. </p><p>由于在shorturl.api文件中已经定义好了两个路由, 所以可以直接去请求api网关接口测试</p><p><strong>发起请求测试</strong></p><p><code>curl -i "http://localhost:8888/shorten?url=http://www.xiaoheiban.cn"</code></p><p>返回信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Thu, 29 Apr 2021 08:20:51 GMT</span><br><span class="line">Content-Length: 14</span><br><span class="line"></span><br><span class="line">{"shorten":""}</span><br></pre></td></tr></tbody></table></figure><p>因为当前没有对生成的代码做任何的逻辑处理, 所以就直接返回shorturl.api文件中定义的shortenResp的默认值. </p><p>如果需要修改返回逻辑可以直接像下面这么操作</p><ul><li>可以修改 <code>internal/svc/servicecontext.go</code> 来传递服务依赖（如果需要）</li><li>实现逻辑可以修改 <code>internal/logic</code> 下的对应文件</li></ul><p>但是直接修改里面的返回逻辑的话, 就又变成单体应用了, 就不符合这是个微服务框架demo的初衷. 所以接下来需要编写rpc程序来实现相关的业务逻辑代码. </p><h3 id="编写-transform-rpc-服务"><a href="#编写-transform-rpc-服务" class="headerlink" title="编写 transform rpc 服务"></a>编写 transform rpc 服务</h3><h4 id="编写-transform-proto-文件"><a href="#编写-transform-proto-文件" class="headerlink" title="编写 transform.proto 文件"></a>编写 <code>transform.proto</code> 文件</h4><p>由于服务之间通信是使用grpc,  因而需要按照grpc的逻辑来编写rpc的逻辑.  </p><p>grpc的基础思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 作为接口定义语言，来描述服务接口和有效载荷消息结构。</p><p>Protobuf的语法教程可以参考这篇博客 [ <a href="">Protobuf 终极教程</a>] 和<a href="https://developers.google.com/protocol-buffers/docs/overview#services">官方教程</a></p><p>首先在rpc目录下<strong>创建transform目录</strong>, 代表这个一个Transform服务, 进入到对应目录, 然后需要编写proto文件,  这个可以通过goctl工具生成一个模板文件. </p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> transform;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">expandReq</span> {</span><br><span class="line">  <span class="type">string</span> shorten = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">expandResp</span> {</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">shortenReq</span> {</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">shortenResp</span> {</span><br><span class="line">  <span class="type">string</span> shorten = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义rpc传输的格式</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">transform</span> {</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> shorten(shortenReq) <span class="keyword">returns</span>(shortenResp)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> expand(expandReq) <span class="keyword">returns</span>(expandResp)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="生成rpc代码"><a href="#生成rpc代码" class="headerlink" title="生成rpc代码"></a>生成rpc代码</h4><p>定义好了服务之间通信的数据格式和相应服务, 接下来就可以用goctl工具生成相应rpc代码. 这一命令依赖于protoc生成代码工具, 需要事先在环境准备中准备完整. </p><p><code>goctl rpc proto -src transform.proto -dir .</code> 执行完成之后, 会生成如下的文件结构:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rpc/transform</span><br><span class="line">├── etc</span><br><span class="line">│   └── transform.yaml              // 配置文件</span><br><span class="line">├── internal</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── config.go               // 配置定义</span><br><span class="line">│   ├── logic</span><br><span class="line">│   │   ├── expandlogic.go          // expand 业务逻辑在这里实现</span><br><span class="line">│   │   └── shortenlogic.go         // shorten 业务逻辑在这里实现</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   └── transformerserver.go    // 调用入口, 不需要修改</span><br><span class="line">│   └── svc</span><br><span class="line">│       └── servicecontext.go       // 定义 ServiceContext，传递依赖</span><br><span class="line">├── transform</span><br><span class="line">│   └── transform.pb.go</span><br><span class="line">├── transform.go                    // rpc 服务 main 函数</span><br><span class="line">├── transform.proto</span><br><span class="line">└── transformer</span><br><span class="line">    ├── transformer.go              // 提供了外部调用方法，无需修改</span><br><span class="line">    ├── transformer_mock.go         // mock 方法，测试用</span><br><span class="line">    └── types.go                    // request/response 结构体定义</span><br></pre></td></tr></tbody></table></figure><p>文件生成之后, 接下来可以直接运行代码. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run transform.<span class="keyword">go</span> -f etc/transform.yaml</span><br></pre></td></tr></tbody></table></figure><p>运行之前, 需要检查一下etcd是否有正常运行, 因为微服务之间的注册发现依赖于etcd来进行管理. </p><h3 id="api网关调用rpc服务"><a href="#api网关调用rpc服务" class="headerlink" title="api网关调用rpc服务"></a>api网关调用rpc服务</h3><p>修改api/etc目录下的配置文件 <code>shorturl-api.yaml</code>，增加如下内容</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Transform:</span></span><br><span class="line">  <span class="attr">Etcd:</span></span><br><span class="line">    <span class="attr">Hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">localhost:2379</span></span><br><span class="line">    <span class="attr">Key:</span> <span class="string">transform.rpc</span></span><br></pre></td></tr></tbody></table></figure><p>通过 etcd 自动去发现可用的 transform 服务.</p><p>接下来需要修改config配置, 添加rpc的依赖选项, 具体是修改 <code>internal/config/config.go</code> 如下，增加 transform 服务依赖.</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">rest.RestConf</span><br><span class="line">Transform zrpc.RpcClientConf</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个config里面添加依赖之后, 简单阅读生成的代码段, 知道这个config会包装成context, 传进与路由匹配的Handler中. 这样我们的业务逻辑就可以利用到这个依赖了, 也就是可以通过rpc调用其他服务的代码了.  这里只是简单的提一下, 后面再来看这里的源码到底是如何实现的. </p><p>修改 <code>internal/svc/servicecontext.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是对原始的config做了一层包装.</span></span><br><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> {</span><br><span class="line">Config config.Config</span><br><span class="line">Transformer transformer.Transformer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceContext</span><span class="params">(c config.Config)</span></span> *ServiceContext {</span><br><span class="line"><span class="keyword">return</span> &amp;ServiceContext{</span><br><span class="line">Config: c,</span><br><span class="line"><span class="comment">// 下面添加Transformer</span></span><br><span class="line">Transformer: transformer.NewTransformer(zrpc.MustNewClient(c.Transform)),</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终不同的业务逻辑之间就是通过这个ServiceContext对象来传递依赖的. </p><p>接下来需要扩充api网关的逻辑. 在expand方法里面补充调用远程rpc接口代码</p><p>修改 <code>internal/logic/expandlogic.go</code> 里的 <code>Expand</code> 方法，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ExpandLogic)</span></span> Expand(req types.ExpandReq) (*types.ExpandResp, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// 在这里是真正实现自己的业务逻辑, 这里调用rpc服务</span></span><br><span class="line">resp, err := l.svcCtx.Transformer.Expand(l.ctx, &amp;transformer.ExpandReq{</span><br><span class="line">Shorten: req.Shorten,</span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> &amp;types.ExpandResp{}, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;types.ExpandResp{Url: resp.Url}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同理需要补充生成短链的调用rpc的代码逻辑. 修改 <code>internal/logic/shortenlogic.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ShortenLogic)</span></span> Shorten(req types.ShortenReq) (*types.ShortenResp, <span class="type">error</span>) {</span><br><span class="line">resp, err := l.svcCtx.Transformer.Shorten(l.ctx, &amp;transformer.ShortenReq{</span><br><span class="line">Url: req.Url,</span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> &amp;types.ShortenResp{}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;types.ShortenResp{Shorten: resp.Shorten}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此, api网关调用rpc的逻辑代码都已书写完毕, 但是rpc之前只是自动生成了代码, 真正的服务代码逻辑还没有实现, 需要接下来去完成. </p><h3 id="数据库与model"><a href="#数据库与model" class="headerlink" title="数据库与model"></a>数据库与model</h3><p>由于短链服务的实现代码是在rpc中完成的, 接下来需要完善一系列逻辑.</p><p>首先是需要用到的mysql和redis数据库. </p><h4 id="定义数据库表"><a href="#定义数据库表" class="headerlink" title="定义数据库表"></a>定义数据库表</h4><p>进入到rpc/transform目录下, 创建model文件夹, 创建<code>shorturl.sql</code>文件</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `shorturl` (</span><br><span class="line">  `shorten` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'shorten key'</span>,</span><br><span class="line">  `url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'original url'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`shorten`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><p>短链服务说简单点就是一个原始长链和生成的短链需要建立一个映射关系, 然后一般需要拿到那个短链来到数据库查原始长链, 然后302重定向原始链接的过程. 所以上面的数据库就设计的比较简单, 只有两个关键字段</p><p>登录到数据库, 创建数据库, 执行刚刚的sql文件. </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database gozero;</span><br><span class="line">use gozero;</span><br><span class="line">source shorturl.sql</span><br></pre></td></tr></tbody></table></figure><p>在model目录下执行命令<code> goctl model mysql ddl -c -src shorturl.sql -dir .</code>可以生成带curd+cache的模板代码.  -c<code>表示使用</code>redis cache</p><p>最后生成的文件结构为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc/transform/model</span><br><span class="line">├── shorturl.sql</span><br><span class="line">├── shorturlmodel.go              // CRUD+cache 代码</span><br><span class="line">└── vars.go                       // 定义常量和变量</span><br></pre></td></tr></tbody></table></figure><h3 id="修改rpc服务"><a href="#修改rpc服务" class="headerlink" title="修改rpc服务"></a>修改rpc服务</h3><h4 id="修改数据库参数"><a href="#修改数据库参数" class="headerlink" title="修改数据库参数"></a>修改数据库参数</h4><p>涉及到数据库的操作, 需要配置数据库连接参数. </p><p>修改 <code>rpc/transform/etc/transform.yaml</code>，增加如下内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DataSource:</span> <span class="string">root:root@tcp(localhost:3306)/gozero</span></span><br><span class="line"><span class="attr">Table:</span> <span class="string">shorturl</span></span><br><span class="line"><span class="attr">Cache:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">localhost:6379</span></span><br></pre></td></tr></tbody></table></figure><p>可以使用多个 redis 作为 cache，支持 redis 单点或者 redis 集群. </p><h4 id="修改依赖文件"><a href="#修改依赖文件" class="headerlink" title="修改依赖文件"></a>修改依赖文件</h4><p>修改<code>rpc/transform/internal/config/config.go</code>文件, 添加数据库相关的依赖</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">zrpc.RpcServerConf</span><br><span class="line"><span class="comment">// 暂时还不知道下面几个配置的具体左右, 需要查看源码来查看. </span></span><br><span class="line">DataSource <span class="type">string</span></span><br><span class="line">Table <span class="type">string</span></span><br><span class="line">Cache cache.CacheConf</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>增加mysql和redis依赖</p><p>修改 <code>rpc/transform/internal/svc/servicecontext.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> {</span><br><span class="line">Config config.Config</span><br><span class="line">Model model.ShorturlModel</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceContext</span><span class="params">(c config.Config)</span></span> *ServiceContext {</span><br><span class="line"><span class="keyword">return</span> &amp;ServiceContext{</span><br><span class="line">Config: c,</span><br><span class="line">Model: model.NewShorturlModel(sqlx.NewMysql(c.DataSource), c.Cache),</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来需要编写生成短链和还原短链的逻辑代码了. </p><p>修改 <code>rpc/transform/internal/logic/expandlogic.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ExpandLogic)</span></span> Expand(in *transform.ExpandReq) (*transform.ExpandResp, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// 根据短链查库还原长链</span></span><br><span class="line">shorturl, err := l.svcCtx.Model.FindOne(in.Shorten)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;transform.ExpandResp{Url: shorturl.Url}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改 <code>rpc/transform/internal/logic/shortenlogic.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ShortenLogic)</span></span> Shorten(in *transform.ShortenReq) (*transform.ShortenResp, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// 简单的实现短链的方法, 只是粗略的实现相关的逻辑. 不考虑重复碰撞的问题.</span></span><br><span class="line">key := hash.Md5Hex([]<span class="type">byte</span>(in.Url))[:<span class="number">6</span>]</span><br><span class="line">_, err := l.svcCtx.Model.Insert(model.Shorturl{</span><br><span class="line">Url:     in.Url,</span><br><span class="line">Shorten: key,</span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;transform.ShortenResp{</span><br><span class="line">Shorten: key,</span><br><span class="line">}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="完整调用测试"><a href="#完整调用测试" class="headerlink" title="完整调用测试"></a>完整调用测试</h3><p>这里面有一个小疑问(必须先启动rpc服务, 然后api网关才能正常启动). </p><p>在终端输入: <code> curl -i "http://localhost:8888/shorten?url=http://www.google.com"</code></p><p>返回信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Fri, 30 Apr 2021 02:36:22 GMT</span><br><span class="line">Content-Length: 20</span><br><span class="line"></span><br><span class="line">{"shorten":"ed646a"}</span><br></pre></td></tr></tbody></table></figure><p>拿到刚才获取到的短链, 然后去获取原始长链</p><p><code>curl -i "http://localhost:8888/expand?shorten=ed646a"</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Fri, 30 Apr 2021 02:36:53 GMT</span><br><span class="line">Content-Length: 31</span><br><span class="line"></span><br><span class="line">{"url":"http://www.google.com"}</span><br></pre></td></tr></tbody></table></figure><p>可以看到正确的返回了原始的长链, 说明demo服务已经完全跑通了. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据go-zero官方的demo示例, 尝试搭建一个shorturl短链服务.&lt;/p&gt;
&lt;h2 id=&quot;搭建短链服务&quot;&gt;&lt;a href=&quot;#搭建短链服务&quot; class=&quot;headerlink&quot; title=&quot;搭建短链服务&quot;&gt;&lt;/a&gt;搭建短链服务&lt;/h2&gt;&lt;h3 id=&quot;环境</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="go-zero" scheme="http://example.com/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>基于frp进行内网穿透</title>
    <link href="http://example.com/2021/04/28/linux/frp-network/"/>
    <id>http://example.com/2021/04/28/linux/frp-network/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于frp进行内网穿透"><a href="#基于frp进行内网穿透" class="headerlink" title="基于frp进行内网穿透"></a>基于<code>frp</code>进行内网穿透</h2><p>公司的数据库环境,服务器环境都是内网环境,  如果想要在家里想要办公, 就需要从公网中访问自己的私有设备(在公司里的电脑),  这不是那么容易.  但是自己搭建<code>frp</code>服务器进行内网穿透，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享, 这也是<code>frp</code>这款开源软件的优势.</p><h3 id="frp了解"><a href="#frp了解" class="headerlink" title="frp了解"></a><code>frp</code>了解</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>frp </code>是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>frp 主要由 <strong>客户端(frpc)</strong> 和 <strong>服务端(frps)</strong> 组成，服务端通常部署在具有公网 IP 的机器上，客户端通常部署在需要穿透的内网服务所在的机器上。</p><p>内网服务由于没有公网 IP，不能被非局域网内的其他用户访问。</p><p>用户通过访问服务端的 frps，由 frp 负责根据请求的端口或其他信息将请求路由到对应的内网机器，从而实现通信。</p><h3 id="frp搭建"><a href="#frp搭建" class="headerlink" title="frp搭建"></a><code>frp</code>搭建</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li><p>一台需要准备公网上的服务器</p></li><li><p>一台处于内网中的可以连接网络的待访问目标设备.</p></li></ul><h4 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h4><p>由于<code>frp</code>是使用go进行开发的, 所以安装及其方便. </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取源码文件, 这是目前为止的最新版</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改名</span></span><br><span class="line">mv frp_0.36.2_linux_amd64 frp</span><br><span class="line"></span><br><span class="line">cd frp</span><br></pre></td></tr></tbody></table></figure><p><code>frp</code>服务端主要有两个文件以s结尾(server)的文件需要关注.</p><p><code>frps </code>和<code>frps.ini </code></p><p><code>frps</code>是可执行文件, 后者是配置文件</p><p>参考配置可以是如下</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 端口配置为12139</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">12139</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = xxxxx</span><br><span class="line"><span class="comment"># vhost_http_port = 10080</span></span><br><span class="line"><span class="comment"># vhost_https_port = 10443</span></span><br></pre></td></tr></tbody></table></figure><ul><li>“bind_port”表示用于客户端和服务端连接的端口，这个端口号我们之后在配置客户端的时候要用到。</li><li>“dashboard_port”是服务端仪表板的端口，若使用7500端口，在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为服务器的IP）查看frp服务运行信息。</li><li>“token”是用于客户端和服务端连接的口令，相当于秘钥。</li><li>“dashboard_user”和“dashboard_pwd”表示打开仪表板页面登录的用户名和密码。</li><li>“vhost_http_port”和“vhost_https_port”用于反向代理HTTP主机时使用。</li></ul><h4 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></tbody></table></figure><p>上面启动后, 会在当前终端运行, 还需要配置成在<strong>后台运行</strong>, 使用Linux的<code>nohup</code>命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></tbody></table></figure><h4 id="客户端安装与配置"><a href="#客户端安装与配置" class="headerlink" title="客户端安装与配置"></a>客户端安装与配置</h4><p>客户端安装方式如出一辙, 在<code>github</code>上下载对应系统的文件即可. 这里以windows为例.</p><p>下载地址:  <a href="https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_windows_amd64.zip">frp_0.36.2_windows_amd64.zip</a></p><p>下载完解压后和服务端一样, 解压后只需要关注两个c结尾(client)的文件</p><p><code>frpc.ini </code>和 <code>frpc</code></p><p>编辑frpc.ini文件</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">12139</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"><span class="section">[remote]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span>           </span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span></span><br><span class="line"><span class="attr">remote_port</span> =<span class="number">13389</span>  </span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></tbody></table></figure><p>server_addr就是服务端的的地址 token是之前服务端配置的token. </p><p>下面可以配置多个需要代理, 可以是windows的远程端口和ssh的22端口.   local_port表示本地的服务的端口, remote_port表示远程访问的端口(后面如果需要访问当前配置的机器, 需要访问这个remote_port端口). </p><p>配置完启动即可. </p><h4 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></tbody></table></figure><p>客户端也需要后台运行和开机自启, 尤其是windows电脑, 每次重启都需要配置启动, 很麻烦. </p><p>windows开机自启教程可以参考这篇文章 <a href="https://lo-li.cn/239">frp教程</a></p><h4 id="安全访问"><a href="#安全访问" class="headerlink" title="安全访问"></a>安全访问</h4><p>官方文档还提到了安全的问题,  按照上面的方式配置完之后, 相当于把内网的机器(公司的机器)暴露在互联网之中了,  那么需要考虑更安全的方式. 参考官方文档<a href="https://gofrp.org/docs/examples/stcp/">安全地暴露内网服务</a></p><p>可以使用 <code>stcp(secret tcp)</code> 类型的代理可以避免让任何人都能访问到要穿透的服务，但是我们访问也需要运行另外一个 frpc 客户端。</p><h4 id="安全访问配置"><a href="#安全访问配置" class="headerlink" title="安全访问配置"></a>安全访问配置</h4><p>服务端配置不需要进行配置, 但是客户端就需要进行改变了. </p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">12139</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="section">[secret_ssh]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="comment"># 只有 sk 一致的用户才能访问到此服务</span></span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="section">[remote]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span>           </span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span></span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br></pre></td></tr></tbody></table></figure><p>多个一个配置秘钥sk, 但是不在需要remote_port了. 因为我们访问者也需要启动frp客户端, 因此直接与frp服务器进行通信即可.  下面是访问者的客户端配置</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">12139</span></span><br><span class="line"></span><br><span class="line"><span class="section">[secret_ssh_visitor]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="comment"># stcp 的访问者</span></span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="comment"># 要访问的 stcp 代理的名字</span></span><br><span class="line"><span class="attr">server_name</span> = secret_ssh</span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="comment"># 绑定本地端口用于访问 SSH 服务</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[remote_visitor]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="comment"># stcp 的访问者</span></span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="comment"># 要访问的 stcp 代理的名字</span></span><br><span class="line"><span class="attr">server_name</span> = remote</span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">8999</span></span><br></pre></td></tr></tbody></table></figure><p>经过这样配置之后, 启动本地的客户端后, 接下来就可以访问到内网的机器了. </p><h3 id="访问内网机器"><a href="#访问内网机器" class="headerlink" title="访问内网机器"></a>访问内网机器</h3><p>可以通过远程访问工具直接控制内网机器, 或者通过ssh隧道方式来进行访问. </p><p>我们现在需要访问内网上的网站, 可以利用ssh开启一个socks5代理, 然后让浏览器转发到代理上, 但这个需要借助一个<code>SwitchyOmiga</code>的谷歌代理插件. </p><p>开启socks5代理方式</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D  0.0.0.0:8888 username@127.0.0.1 -N -oPort=6000</span><br></pre></td></tr></tbody></table></figure><ul><li>username  是内网机器的用户名</li><li>oPort是本机frpc配置中的bind_port</li></ul><p>这样配置以后就可以访问了. </p><p>如果需要访问内网中的数据库的话, 一般可以借助连接工具, 如<code>navicat</code>一般都会带ssh隧道的连接方式</p><p>下面是navicat的配置方式</p><p><img src="https://gitee.com/yu_binbin/personnal-image/raw/master/mongo1.png" alt="mongo1"></p><p><img src="https://gitee.com/yu_binbin/personnal-image/raw/master/mongo2.png" alt="mongo2"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>frp在windows上会报毒, 我这次是通过下载其他安全软件覆盖掉默认的windows defender,  这次怎么都关不掉windows这个流氓软件(注册表等手段试过都无效), 只能以毒攻毒, 用其他杀毒软件. </li><li>服务端需要启用相应的转发端口. </li><li>windows上的sshd需要自行安装</li><li>windows如果需要远程, 需要开启远程桌面功能, 才能进行自带的远程连接功能.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://sspai.com/post/52523">使用frp进行内网穿透</a></li><li><a href="https://gofrp.org/docs/">官网</a></li><li><a href="https://lo-li.cn/239">windows上frp开机自启</a></li><li><a href="https://zhuanlan.zhihu.com/p/57630633">ssh登录外的其他功能</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">ssh端口转发</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于frp进行内网穿透&quot;&gt;&lt;a href=&quot;#基于frp进行内网穿透&quot; class=&quot;headerlink&quot; title=&quot;基于frp进行内网穿透&quot;&gt;&lt;/a&gt;基于&lt;code&gt;frp&lt;/code&gt;进行内网穿透&lt;/h2&gt;&lt;p&gt;公司的数据库环境,服务器环境都是内网环境,</summary>
      
    
    
    
    <category term="系统" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="linux" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
    <category term="远程连接" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu远程连接windows电脑</title>
    <link href="http://example.com/2021/04/26/linux/ubuntu_remote_connect/"/>
    <id>http://example.com/2021/04/26/linux/ubuntu_remote_connect/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于freerdp远程连接"><a href="#基于freerdp远程连接" class="headerlink" title="基于freerdp远程连接"></a>基于freerdp远程连接</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因工作需要, 需要使用<code>ubuntu</code>连接远程Windows电脑. 在windows电脑上使用向日葵等远程连接软件十分方便, 在<code>ubuntu</code>上当然也有对应的软件可以使用, 这款软件就是 <code>freerdp</code>. </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>虽然有apt-get的方式可以直接安装, 但是这个好像不支持密码为空的连接方式, 就直接使用源码进行安装. </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update -y  # 这步必须要做, 不然可能依赖不能下载完全</span><br><span class="line"></span><br><span class="line">sudo apt-get install git cmake cdbs zlib1g-dev libssl-dev libglib2.0-dev libxml2-dev libxext-dev libsystemd-dev libwayland-dev libxkbcommon-dev libasound2-dev libpulse-dev libcups2-dev libpcsclite-dev libavcodec-dev libavutil-dev libavresample-dev libswresample-dev libxkbfile-dev libxinerama-dev libxcursor-dev libxv-dev libxi-dev libxrandr-dev docbook-xsl libcairo2-dev xsltproc libusb-1.0-0-dev -y</span><br><span class="line"></span><br><span class="line">sudo git clone git://github.com/FreeRDP/FreeRDP.git --branch 2.2.0</span><br><span class="line"></span><br><span class="line">cd FreeRDP</span><br><span class="line"></span><br><span class="line">sudo cmake -DTARGET_ARCH=ARM -DWITH_X11=ON</span><br><span class="line"></span><br><span class="line">sudo make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装成功输入<code>xfreerdp</code>出来软件的帮助信息后, 说明安装成功</p><p>这个命令的参数有点多, 可以直接参考help, 这里只介绍几个参数的作用</p><ul><li><p><strong>/v</strong> 主机<code>ip</code>和地址 形式如 <code>/v:192.168.1.100:4489</code></p></li><li><p><strong>/p</strong> 密码 </p></li><li><p><strong>/u</strong> 用户名</p></li><li><p><strong>/f</strong> 全屏</p></li><li><p><strong>/bpp</strong>  色彩度指定, 当网络速度不快时, 或者需要降低延迟, 这个值可以指定的比较小</p></li><li><p><strong>/drive</strong>  指定挂载主机的目录, 会在远程主机中出现一个虚拟目录, 这个目录用来互相传送文件. 使用方式例如 <code>/drive:Mount,/home/yscl/</code> 这里的mount指的是挂载的目录名字</p></li><li><p><strong>/w</strong>  宽度width</p></li><li><p><strong>/h</strong> 高度height</p></li></ul><p>使用demo</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /u:JohnDoe /p:Pwd123! /w:1366 /h:768 /v:192.168.1.100:4489</span><br><span class="line"></span><br><span class="line"> xfreerdp /v:127.0.0.1 /u:Administrator /p: /f /bpp:8</span><br></pre></td></tr></tbody></table></figure><p>说明一句, windows的远程访问端口为3389, 当我们连接成功后, 可以按<code>crtl+ alt +enter</code> 退出全屏</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=292360">https://www.raspberrypi.org/forums/viewtopic.php?t=292360</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于freerdp远程连接&quot;&gt;&lt;a href=&quot;#基于freerdp远程连接&quot; class=&quot;headerlink&quot; title=&quot;基于freerdp远程连接&quot;&gt;&lt;/a&gt;基于freerdp远程连接&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="系统" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="linux" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F/linux/"/>
    
    
    <category term="远程连接" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose搭建mongo集群</title>
    <link href="http://example.com/2021/04/16/mongo/docker_cluster/"/>
    <id>http://example.com/2021/04/16/mongo/docker_cluster/</id>
    <published>2021-04-15T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<boxx><h2 id="使用docker-compose搭建mongo集群"><a href="#使用docker-compose搭建mongo集群" class="headerlink" title="使用docker-compose搭建mongo集群"></a>使用docker-compose搭建mongo集群</h2><p>参考github上的docker-compose搭建mongo集群链接： <a href="https://github.com/minhhungit/mongodb-cluster-docker-compose">https://github.com/minhhungit/mongodb-cluster-docker-compose</a> </p><p>记一下搭建与学习过程， 顺便再学习记录下docker-compose的写法。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>mongodb集群搭建方式通常有3种：</p><ol><li>主从（Master - Slave）模式</li><li>副本集（Replica Set）模式</li><li>分片（Sharding）模式</li></ol><p>这次采用的是Replica Set +  Sharding的模式来搭建的高可用的mongo集群， 下图是github上集群的架构。</p><p><img src="https://gitee.com/yu_binbin/personnal-image/raw/master/sharding-and-replica-sets.png" alt="sharding-and-replica-sets"></p><p>依照架构图， 这次集群的配置如下：</p><ul><li>配置服务器（Config Server ）由3个配置服务器组成一个<code>replica set</code>， 对应configsvr01<code>,</code>configsvr02<code>,</code>configsvr03</li><li>3个Shard节点， 每个shard节点又是由3个shard服务器组成的一个<code>replica set</code>对应如下：<ul><li><code>shard01-a</code>,<code>shard01-b</code>, <code>shard01-c</code></li><li><code>shard02-a</code>,<code>shard02-b</code>, <code>shard02-c</code></li><li><code>shard03-a</code>,<code>shard03-b</code>, <code>shard03-c</code></li></ul></li><li>2个路由(Routers) mongos服务器: <code>router01</code>, <code>router02</code></li></ul><p>构建一个 mongoDB Sharding Cluster 需要三种角色:shard 服务器(ShardServer)、配置服务器(config Server)、路由进程(Route Process)</p><p>构建一个 mongoDB Sharding Cluster 需要三种角色:shard 服务器(ShardServer)、配置服务器(config Server)、路由进程(Route Process)</p><p><strong>shard 服务器</strong></p><p>　　shard 服务器即存储实际数据的分片,每个 shard 可以是一个 mongod 实例, 也可以是一组 mongod 实例构成的 Replica Sets.为了实现每个 Shard 内部的故障 自动转换,MongoDB 官方建议每个 shard 为一组 Replica Sets.</p><p><strong>配置服务器</strong></p><p>​         为了将一个特定的 collection 存储在多个 shard 中,需要为该 collection 指定 一个 shard key,决定该条记录属于哪个 chunk,配置服务器可以存储以下信息, 每个shard节点的配置信息,每个chunk的shard key范围,chunk在各shard 的分布情况,集群中所有 DB 和 collection 的 sharding 配置信息。</p><p><strong>路由进程（mongos）</strong></p><p>​         它是一个前端路由,客户端由此接入,首先询问配置服务器需要到哪个 shard 上查询或保存记录,然后连接相应的 shard 执行操作,最后将结果返回给客户端,客户端只需要将原本发给 mongod 的查询或更新请求原封不动地发给路由进程,而不必关心所操作的记录存储在哪个 shard 上。</p><h3 id="docker-compose配置"><a href="#docker-compose配置" class="headerlink" title="docker-compose配置"></a>docker-compose配置</h3><blockquote><p> docker-compose.yml</p></blockquote><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Router</span></span><br><span class="line">  <span class="attr">router01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-router-01</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongos</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configdb</span> <span class="string">rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017</span> <span class="string">--bind_ip_all</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27117</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">  <span class="attr">router02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-router-02</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongos</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configdb</span> <span class="string">rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017</span> <span class="string">--bind_ip_all</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27118</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">router01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Config Servers</span></span><br><span class="line">  <span class="attr">configsvr01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-01</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27119</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-a</span></span><br><span class="line">  <span class="attr">configsvr02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-02</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27120</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configsvr01</span></span><br><span class="line">  <span class="attr">configsvr03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-03</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27121</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configsvr02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Shards</span></span><br><span class="line">  <span class="comment">## Shards 01</span></span><br><span class="line">   </span><br><span class="line">  <span class="attr">shard01-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27122</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-c</span></span><br><span class="line">  <span class="attr">shard01-b:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-b</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27123</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">shard01-c:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-c</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27124</span><span class="string">:27017</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Shards 02</span></span><br><span class="line">  <span class="attr">shard02-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-02-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-02</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27125</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-c</span></span><br><span class="line">  <span class="attr">shard02-b:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-02-node-b</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-02</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27126</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">shard02-c:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-02-node-c</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-02</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27127</span><span class="string">:27017</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Shards 03</span></span><br><span class="line">  <span class="attr">shard03-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-03-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-03</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27128</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-c</span></span><br><span class="line">  <span class="attr">shard03-b:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-03-node-b</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-03</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27129</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">shard03-c:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-03-node-c</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-03</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27130</span><span class="string">:27017</span></span><br></pre></td></tr></tbody></table></figure><p>整个docker-compose文件组要分成3大块， 对应于mongo集群的3个组件</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong>Router</strong></h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">router01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-router-01</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongos</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configdb</span> <span class="string">rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017</span> <span class="string">--bind_ip_all</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27117</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br></pre></td></tr></tbody></table></figure><p>上面是<code>router01</code>的配置， 简单解读下</p><p>服务名为router01，启动容器使用的镜像为mongo:4.0， 启动后的容器名字是<code>rydell-router-01</code>， 容器启动后绑定的端口号为宿主机：容器（27117:27017）,  数据文件夹， 将容器内部的scripts文件夹挂载到当前目录的scripts文件夹下， 这里还可以配置mongo的配置文件，数据文件夹等的挂载目录。command参数表示容器启动后执行的命令：</p><p><code>mongos --port 27017 --configdb rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017 --bind_ip_all</code></p><p>上面的命令涉及到几个配置， 具体的使用方式可以参考<a href="https://docs.mongodb.com/manual/reference/program/mongos/">mongodb官网</a></p><p><strong>–port:</strong> mongos启动监听的端口号</p><p><strong>–configdb:</strong>  指定集群的配置服务器 指定格式是<code>--configdb &lt;replicasetName&gt;/&lt;config1&gt;,&lt;config2&gt;...</code></p><p>需要指定配置服务器组成的<code>replica set</code>的名字以及配置服务器的ip和port</p><p><strong>–bind_ip_all:</strong> 监听所有ip的连接， 相当于<code>--bind_ip 0.0.0.0</code></p><p>上面配置的时候直接以服务名作为host， 这个涉及到docker-compose的网络配置。 在docker-compose启动后， 会创建以docker-compose文件<code>所在文件夹名字_default</code>的网络， 然后文件中的服务启动后，会以服务名加入这个网络，这样容器之间可以使用服务名称作为hostname相互访问。网络的具体解析可以参考这篇博客” <a href="https://juejin.cn/post/6844903976534540296">Docker Compose 网络设置</a> “， 写得非常详细.</p><h4 id="Config-Servers"><a href="#Config-Servers" class="headerlink" title="Config Servers"></a><strong>Config Servers</strong></h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configsvr01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-01</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27119</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-a</span></span><br></pre></td></tr></tbody></table></figure><p>这里只看容器启动后执行的命令 <code>mongod --port 27017 --configsvr --replSet rs-config-server</code></p><p>这里的使用方式可以参考<a href="https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/#start-each-member-of-the-config-server-replica-set">官方文档开启配置服务器</a></p><p><strong>–replSet</strong>  指定一个<code>Replica Set</code>的名字，集合内所有服务器必须拥有相同的名字</p><p><strong>–configsvr</strong> 启动一个配置服务器必须要指定的参数</p><h4 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a><strong>Shard</strong></h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shard01-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27122</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-c</span></span><br></pre></td></tr></tbody></table></figure><p>还是只看容器启动后执行的命令 <code>mongod --port 27017 --shardsvr --replSet rs-shard-01</code></p><p><strong>–replSet</strong>  指定一个<code>Replica Set</code>的名字，集合内所有服务器必须拥有相同的名字</p><p><strong>–shardsvr</strong> 启动一个shard服务器必须要指定的参数</p><h3 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h3><p>上面执行<code>docker-compose up -d</code>的命令后已经启动了mongo集群的3个组件， 集群还需要进行初始化操作。</p><p><strong>初始化配置服务器</strong></p><p><code>docker-compose exec configsvr01 sh -c "mongo &lt; /scripts/init-configserver.js"</code></p><p><code>init-configserver.js</code>脚本文件内容如下所示</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">initiate</span>( {</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">"rs-config-server"</span>, </span><br><span class="line">    <span class="attr">configsvr</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">version</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">members</span>: [</span><br><span class="line">         { <span class="attr">_id</span>: <span class="number">0</span>, host : <span class="string">'configsvr01:27017'</span> },</span><br><span class="line">         { <span class="attr">_id</span>: <span class="number">1</span>, host : <span class="string">'configsvr02:27017'</span> }, </span><br><span class="line">         { <span class="attr">_id</span>: <span class="number">2</span>, host : <span class="string">'configsvr03:27017'</span> } </span><br><span class="line">     ] })</span><br></pre></td></tr></tbody></table></figure><p>上面是通过docker-compose 的exec命令进入到容器内部执行命令， 相当于docker原生命令<code>docker exec -it $DOCKER_ID /bin/bash -c 'command'</code></p><p>这条命令的主要作用就是先连接任意一个配置服务器， 然后初始化<code>replica set</code>， 上面的参数</p><ul><li>_id:   <code>replica set</code>名字</li><li>configsvr： 如果是配置服务器， 就指定为true</li><li>members： 集合内成员的id和host配置</li><li>version： 版本号</li></ul><p>更多的<code>replica set</code>配置可以参考<a href="https://docs.mongodb.com/manual/reference/replica-configuration/">官方文档<code>replica set</code>配置部分</a></p><p><strong>初始化每个shard服务器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec shard01-a sh -c "mongo &lt; /scripts/init-shard01.js"</span><br><span class="line">docker-compose exec shard02-a sh -c "mongo &lt; /scripts/init-shard02.js"</span><br><span class="line">docker-compose exec shard03-a sh -c "mongo &lt; /scripts/init-shard03.js"</span><br></pre></td></tr></tbody></table></figure><p>上面三个脚本的内容类似， 下面是init-shard01.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">initiate</span>({</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">"rs-shard-01"</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">members</span>: [</span><br><span class="line">        {<span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">"shard01-a:27017"</span>}, </span><br><span class="line">        {<span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">"shard01-b:27017"</span>}, </span><br><span class="line">        {<span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">"shard01-c:27017"</span>}</span><br><span class="line">    ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>还是初始化shard节点组成的<code>replica set</code>， 指定成员之类的操作。</p><p><strong>初始化路由(mongos)</strong></p><blockquote><p> 执行下面的操作之前需要稍微等待一会， 因为配置服务器和shard服务器需要先互相通信选取主节点</p></blockquote><p>执行<code>docker-compose exec router01 sh -c "mongo &lt; /scripts/init-router.js"</code></p><p>init-router.js文件内容如下所示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-01/shard01-a:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-01/shard01-b:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-01/shard01-c:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-02/shard02-a:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-02/shard02-b:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-02/shard02-c:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-03/shard03-a:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-03/shard03-b:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-03/shard03-c:27017"</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面的命令先连接到集群中， 我们连接连接集群主要需要与mongos服务器打交道，所以先连接任意一个路由进程， 将shard节点添加进去</p><p>添加shard节点方法参数：<code>sh.addShard("&lt;replica_set&gt;/&lt;hostname&gt;&lt;:port&gt;")</code></p><h3 id="开启分片"><a href="#开启分片" class="headerlink" title="开启分片"></a>开启分片</h3><p>在对表分片之前， 必须开启数据库的分片功能， 这行命令是<code>sh.enableSharding("&lt;database&gt;")</code>. 表示对指定的数据库进行分片</p><p>对数据库指定需要开启分片功能, 然后需要指定该数据库下某张表执行分片的依据. 即指定<code>sharding key</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.<span class="title function_">shardCollection</span>(<span class="string">"&lt;database&gt;.&lt;collection&gt;"</span>, { <span class="language-xml"><span class="tag">&lt;<span class="name">shard</span> <span class="attr">key</span> <span class="attr">field</span>&gt;</span> : "hashed" } )</span></span><br></pre></td></tr></tbody></table></figure><p>或者使用demo中例子的命令: </p><p><code>db.adminCommand( { shardCollection: "MyDatabase.MyCollection", key: { supplierId: "hashed" } } )</code>含义与上面一致.</p><p>至此, mongo集群的搭建就已经基本成功了, 接下来的操作就是连接上mongos服务器, 插入数据来进行测试了. </p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/minhhungit/mongodb-cluster-docker-compose">https://github.com/minhhungit/mongodb-cluster-docker-compose</a></li><li><a href="https://segmentfault.com/a/1190000023144572?utm_source=sf-similar-article">基于docker容器下mongodb 4.0.0 的Replica Sets+Sharded Cluster集群</a></li><li><a href="https://blog.csdn.net/quanmaoluo5461/article/details/85164588#t15">Docker搭建高可用的mongodb副本集+分片</a></li><li><a href="https://segmentfault.com/a/1190000039142073">https://segmentfault.com/a/1190000039142073</a></li></ul></boxx>]]></content>
    
    
      
      
    <summary type="html">&lt;boxx&gt;

&lt;h2 id=&quot;使用docker-compose搭建mongo集群&quot;&gt;&lt;a href=&quot;#使用docker-compose搭建mongo集群&quot; class=&quot;headerlink&quot; title=&quot;使用docker-compose搭建mongo集群&quot;&gt;&lt;/a&gt;使用d</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mongo" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/"/>
    
    
    <category term="集群" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
    <category term="mongo" scheme="http://example.com/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>tornado官方demo</title>
    <link href="http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2-tornado%E5%AE%98%E6%96%B9demo/"/>
    <id>http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/2-tornado%E5%AE%98%E6%96%B9demo/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>tornado框架初体验， 永远的<code>hello world</code></p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>在官方基础demo上加了一些执行顺序的代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, Awaitable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainHandler</span>(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare</span>(<span class="params">self</span>) -&gt; <span class="type">Optional</span>[Awaitable[<span class="literal">None</span>]]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'prepare....'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">self, database</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.database = database</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'initialize....'</span>, database)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_default_headers</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'set_default_headers...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_error</span>(<span class="params">self, status_code: <span class="built_in">int</span>, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'write_error...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_finish</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'on_finish...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'hello world...'</span>)</span><br><span class="line">        self.write(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_app</span>():</span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r'/'</span>, MainHandler, <span class="built_in">dict</span>(database=<span class="string">'mysql...'</span>)),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在浏览器上输入路由后， 清晰的看到执行顺序</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_default_headers...</span><br><span class="line">initialize.... mysql...</span><br><span class="line">prepare....</span><br><span class="line">hello world...</span><br><span class="line">on_finish...</span><br></pre></td></tr></tbody></table></figure><ol><li><code>set_default_headers()</code>设置默认返回头部的方法</li><li><code>initialize()</code>这个是类实例初始化会调用的方法，可以增加初始化的功能</li><li><code>prepare()</code>这个是预先处理方法，可以在处理HTTP请求的方法执行前调用进行一些预处理</li><li><code>HTTP方法</code>方法名为：get, post, head, delete, put, patch, options的方法，用来处理对应的HTTP方法的请求</li><li><code>on_finish()</code>结束请求的时候执行这个方法</li></ol><p>上面就是tornado的基础使用方式 ， 还是非常简单的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tornado框架初体验， 永远的&lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h4&gt;&lt;p&gt;在官方基础demo上加了一</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="tornado" scheme="http://example.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>application_初始化阅读</title>
    <link href="http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/3-application_%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%85%E8%AF%BB/"/>
    <id>http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/3-application_%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%85%E8%AF%BB/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始从<code>HelloWorld</code>的demo开始阅读源码。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">        (<span class="string">r'/'</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">app.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></tbody></table></figure><p>上面三行代码是先从实例化一个<code>webApp</code>开始的， 那么接下来开始看这个Application的源码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>(<span class="title class_ inherited__">ReversibleRouter</span>):</span><br><span class="line">    <span class="string">r"""A collection of request handlers that make up a web application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Instances of this class are callable and can be passed directly to</span></span><br><span class="line"><span class="string">    HTTPServer to serve the application::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        application = web.Application([</span></span><br><span class="line"><span class="string">            (r"/", MainPageHandler),</span></span><br><span class="line"><span class="string">        ])</span></span><br><span class="line"><span class="string">        http_server = httpserver.HTTPServer(application)</span></span><br><span class="line"><span class="string">        http_server.listen(8080)</span></span><br><span class="line"><span class="string">        ioloop.IOLoop.current().start()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        handlers: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        default_host: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        transforms: <span class="type">Optional</span>[<span class="type">List</span>[<span class="type">Type</span>[<span class="string">"OutputTransform"</span>]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **settings: <span class="type">Any</span></span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param handlers: 处理业务逻辑的包含路由设置的handlers</span></span><br><span class="line"><span class="string">        :param default_host: 默认的启动后的host</span></span><br><span class="line"><span class="string">        :param transforms: 设置响应结果传输的方式</span></span><br><span class="line"><span class="string">        :param settings:  application的配置</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置了transforms参数会在响应头中添加Content-Encoding='gzip'</span></span><br><span class="line">        <span class="keyword">if</span> transforms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transforms = []  <span class="comment"># type: <span class="type">List</span>[<span class="type">Type</span>[OutputTransform]]</span></span><br><span class="line">            <span class="comment"># 如果需要压缩响应结果， 需要在结果中设置compress_response或gzip参数为True</span></span><br><span class="line">            <span class="keyword">if</span> settings.get(<span class="string">"compress_response"</span>) <span class="keyword">or</span> settings.get(<span class="string">"gzip"</span>):</span><br><span class="line">                self.transforms.append(GZipContentEncoding)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.transforms = transforms</span><br><span class="line">        <span class="comment"># 默认host</span></span><br><span class="line">        self.default_host = default_host</span><br><span class="line">        <span class="comment"># 加载所有初始化后传入的settings</span></span><br><span class="line">        self.settings = settings</span><br><span class="line">        <span class="comment"># 模板相关的配置</span></span><br><span class="line">        self.ui_modules = {</span><br><span class="line">            <span class="string">"linkify"</span>: _linkify,</span><br><span class="line">            <span class="string">"xsrf_form_html"</span>: _xsrf_form_html,</span><br><span class="line">            <span class="string">"Template"</span>: TemplateModule,</span><br><span class="line">        }</span><br><span class="line">        self.ui_methods = {}  <span class="comment"># type: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Callable</span>[..., <span class="built_in">str</span>]]</span></span><br><span class="line">        <span class="comment"># 获取自定义的UIModule和UIMethods</span></span><br><span class="line">        self._load_ui_modules(settings.get(<span class="string">"ui_modules"</span>, {}))</span><br><span class="line">        self._load_ui_methods(settings.get(<span class="string">"ui_methods"</span>, {}))</span><br><span class="line">        <span class="comment"># 检查settings有没有配置静态资源的路径</span></span><br><span class="line">        <span class="keyword">if</span> self.settings.get(<span class="string">"static_path"</span>):</span><br><span class="line">            path = self.settings[<span class="string">"static_path"</span>]</span><br><span class="line">            handlers = <span class="built_in">list</span>(handlers <span class="keyword">or</span> [])</span><br><span class="line">            <span class="comment"># 默认的静态资源路径为/static/资源的地址</span></span><br><span class="line">            static_url_prefix = settings.get(<span class="string">"static_url_prefix"</span>, <span class="string">"/static/"</span>)</span><br><span class="line">            <span class="comment"># 静态资源的处理Handler， 可以自己传，也可以使用默认的Handler</span></span><br><span class="line">            static_handler_class = settings.get(</span><br><span class="line">                <span class="string">"static_handler_class"</span>, StaticFileHandler</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># static_handler_args参数是传递给文件处理Handler执行initialize函数初始化的参数</span></span><br><span class="line">            static_handler_args = settings.get(<span class="string">"static_handler_args"</span>, {})</span><br><span class="line">            static_handler_args[<span class="string">"path"</span>] = path</span><br><span class="line">            <span class="comment"># 默认会添加3条静态资源相关的路由地址</span></span><br><span class="line">            <span class="keyword">for</span> pattern <span class="keyword">in</span> [</span><br><span class="line">                re.escape(static_url_prefix) + <span class="string">r"(.*)"</span>,</span><br><span class="line">                <span class="string">r"/(favicon\.ico)"</span>,</span><br><span class="line">                <span class="string">r"/(robots\.txt)"</span>,</span><br><span class="line">            ]:</span><br><span class="line">                handlers.insert(<span class="number">0</span>, (pattern, static_handler_class, static_handler_args))</span><br><span class="line">        <span class="comment"># 检查是否配置是debug模式</span></span><br><span class="line">        <span class="keyword">if</span> self.settings.get(<span class="string">"debug"</span>):</span><br><span class="line">            <span class="comment"># 自动重载</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"autoreload"</span>, <span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 取消编译模板缓存</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"compiled_template_cache"</span>, <span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># 取消静态文件的hash值缓存</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"static_hash_cache"</span>, <span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># 提供处理跟踪信息</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"serve_traceback"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加路由， 这个也是这个app最重要的一个部分</span></span><br><span class="line">        self.wildcard_router = _ApplicationRouter(self, handlers)</span><br><span class="line">        self.default_router = _ApplicationRouter(</span><br><span class="line">            self, [Rule(AnyMatches(), self.wildcard_router)]</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 自动重载</span></span><br><span class="line">        <span class="comment"># Automatically reload modified modules</span></span><br><span class="line">        <span class="keyword">if</span> self.settings.get(<span class="string">"autoreload"</span>):</span><br><span class="line">            <span class="keyword">from</span> tornado <span class="keyword">import</span> autoreload</span><br><span class="line"></span><br><span class="line">            autoreload.start()</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure><p>跟踪上面的<code>_ApplicationRouter</code>类代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_ApplicationRouter</span>(<span class="title class_ inherited__">ReversibleRuleRouter</span>):</span><br><span class="line">    <span class="string">"""Routing implementation used internally by `Application`.</span></span><br><span class="line"><span class="string">这是一个用来绑定应用程序和RequestHandler的类， 通过路由建立桥梁。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, application: <span class="string">"Application"</span>, rules: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(application, Application)</span><br><span class="line">        self.application = application</span><br><span class="line">        <span class="built_in">super</span>().__init__(rules)</span><br></pre></td></tr></tbody></table></figure><p>上面这个类继承自<code>ReversibleRuleRouter</code>， 继续跟踪代码往下。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReversibleRuleRouter</span>(ReversibleRouter, RuleRouter):</span><br><span class="line">    <span class="string">"""A rule-based router that implements ``reverse_url`` method.</span></span><br><span class="line"><span class="string">这个类实现了反向解析类reverse_url方法， 这个功能一般是在模板里面使用的，能够根据名字反向解析出url</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rules: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.named_rules = {}  <span class="comment"># type: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(rules)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_rule</span>(<span class="params">self, rule: <span class="string">"Rule"</span></span>) -&gt; <span class="string">"Rule"</span>:</span><br><span class="line">        rule = <span class="built_in">super</span>().process_rule(rule)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rule.name:</span><br><span class="line">            <span class="keyword">if</span> rule.name <span class="keyword">in</span> self.named_rules:</span><br><span class="line">                app_log.warning(</span><br><span class="line">                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>, rule.name</span><br><span class="line">                )</span><br><span class="line">            <span class="comment"># 将路由的名字与对应的rule规则映射起来。    </span></span><br><span class="line">            self.named_rules[rule.name] = rule</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rule</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_url</span>(<span class="params">self, name: <span class="built_in">str</span>, *args: <span class="type">Any</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">"""反向解析功能的实现（根据名字来获取映射的url）"""</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.named_rules:</span><br><span class="line">            <span class="keyword">return</span> self.named_rules[name].matcher.reverse(*args)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> self.rules:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(rule.target, ReversibleRouter):</span><br><span class="line">                reversed_url = rule.target.reverse_url(name, *args)</span><br><span class="line">                <span class="keyword">if</span> reversed_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> reversed_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><p>看到这里上面的这个类还是还是没有真正的添加路由规则， 它还继承了另一个核心类<code>RuleRouter</code>， 继续跟踪下去。 </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RuleRouter</span>(<span class="title class_ inherited__">Router</span>):</span><br><span class="line">    <span class="string">"""Rule-based router implementation."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rules: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""Constructs a router from an ordered list of rules::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            RuleRouter([</span></span><br><span class="line"><span class="string">                Rule(PathMatches("/handler"), Target),</span></span><br><span class="line"><span class="string">                # ... more rules</span></span><br><span class="line"><span class="string">            ])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        You can also omit explicit `Rule` constructor and use tuples of arguments::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            RuleRouter([</span></span><br><span class="line"><span class="string">                (PathMatches("/handler"), Target),</span></span><br><span class="line"><span class="string">            ])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        `PathMatches` is a default matcher, so the example above can be simplified::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            RuleRouter([</span></span><br><span class="line"><span class="string">                ("/handler", Target),</span></span><br><span class="line"><span class="string">            ])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        In the examples above, ``Target`` can be a nested `Router` instance, an instance of</span></span><br><span class="line"><span class="string">        `~.httputil.HTTPServerConnectionDelegate` or an old-style callable,</span></span><br><span class="line"><span class="string">        accepting a request argument.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg rules: a list of `Rule` instances or tuples of `Rule`</span></span><br><span class="line"><span class="string">            constructor arguments.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.rules = []  <span class="comment"># type: <span class="type">List</span>[Rule]</span></span><br><span class="line">        <span class="keyword">if</span> rules:</span><br><span class="line">            <span class="comment"># 这里是真正的添加规则</span></span><br><span class="line">            self.add_rules(rules)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_rules</span>(<span class="params">self, rules: _RuleList</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""Appends new rules to the router.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg rules: a list of Rule instances (or tuples of arguments, which are</span></span><br><span class="line"><span class="string">            passed to Rule constructor).</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> rules:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(rule, (<span class="built_in">tuple</span>, <span class="built_in">list</span>)):</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">len</span>(rule) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(rule[<span class="number">0</span>], basestring_type):</span><br><span class="line">                    rule = Rule(PathMatches(rule[<span class="number">0</span>]), *rule[<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rule = Rule(*rule)</span><br><span class="line"></span><br><span class="line">            self.rules.append(self.process_rule(rule))</span><br></pre></td></tr></tbody></table></figure><p>看到这里其实已经豁然开朗了， 最终会把规则放入<code>_ApplicationRouter</code>对象的<code>rules</code>属性中， 就是app的<code>wildcard_router</code>属性中可以直接获取到。 </p><p>接下来可以看看Rule对象的具体结构， 这个Rule对象保存了路由规则以及target处理的映射关系。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">"""A routing rule."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        matcher: <span class="string">"Matcher"</span>,</span></span><br><span class="line"><span class="params">        target: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">        target_kwargs: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""Constructs a Rule instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg Matcher matcher: a `Matcher` instance used for determining</span></span><br><span class="line"><span class="string">            whether the rule should be considered a match for a specific</span></span><br><span class="line"><span class="string">            request.</span></span><br><span class="line"><span class="string">        :arg target: a Rule's target (typically a ``RequestHandler`` or</span></span><br><span class="line"><span class="string">            `~.httputil.HTTPServerConnectionDelegate` subclass or even a nested `Router`,</span></span><br><span class="line"><span class="string">            depending on routing implementation).</span></span><br><span class="line"><span class="string">        :arg dict target_kwargs: a dict of parameters that can be useful</span></span><br><span class="line"><span class="string">            at the moment of target instantiation (for example, ``status_code``</span></span><br><span class="line"><span class="string">            for a ``RequestHandler`` subclass). They end up in</span></span><br><span class="line"><span class="string">            ``target_params['target_kwargs']`` of `RuleRouter.get_target_delegate`</span></span><br><span class="line"><span class="string">            method.</span></span><br><span class="line"><span class="string">        :arg str name: the name of the rule that can be used to find it</span></span><br><span class="line"><span class="string">            in `ReversibleRouter.reverse_url` implementation.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(target, <span class="built_in">str</span>):</span><br><span class="line">            <span class="comment"># import the Module and instantiate the class</span></span><br><span class="line">            <span class="comment"># Must be a fully qualified name (module.ClassName)</span></span><br><span class="line">            target = import_object(target)</span><br><span class="line"></span><br><span class="line">        self.matcher = matcher  <span class="comment"># type: Matcher</span></span><br><span class="line">        self.target = target</span><br><span class="line">        self.target_kwargs = target_kwargs <span class="keyword">if</span> target_kwargs <span class="keyword">else</span> {}</span><br><span class="line">        self.name = name</span><br></pre></td></tr></tbody></table></figure><p>一条路由规则组成结构还是比较简单的， 一共就4部分， 上面的英文文档其实已经说的比较清楚了</p><ul><li>matcher  其实就是在我们写的正则路由中包装了一层</li><li>target   request请求开始后路由到对应的target对象去处理， 这个target对象可以是典型的<code>RequestHandler</code>或是<code>httputil.HTTPServerConnectionDelegate</code>的实现类或是还可以是一个嵌套的<code>Router</code>类实例</li><li>target_kwargs  顾名思义， 就是给target（请求处理对象）的参数</li><li>name   路由反向解析的名字</li></ul><p>到这也基本可以明白一个app初始化后， 主要就是一些内部参数的初始化， 以及最重要的路由绑定等等处理。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里开始从&lt;code&gt;HelloWorld&lt;/code&gt;的demo开始阅读源码。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="tornado" scheme="http://example.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>启动httpserver</title>
    <link href="http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/4-%E5%90%AF%E5%8A%A8httpserver/"/>
    <id>http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/4-%E5%90%AF%E5%8A%A8httpserver/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>看看启动server的代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">        (<span class="string">r'/'</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">app.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></tbody></table></figure><p>第一行代码只是简单的初始化了应用<code>app</code>， 而没有实际启动<code>httpserver </code>， 下面分析如何启动<code>httpsever</code>的。 </p><p>进入源码分析</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self, port: <span class="built_in">int</span>, address: <span class="built_in">str</span> = <span class="string">""</span>, **kwargs: <span class="type">Any</span></span>) -&gt; HTTPServer:</span><br><span class="line">    <span class="string">"""Starts an HTTP server for this application on the given port.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is a convenience alias for creating an `.HTTPServer`</span></span><br><span class="line"><span class="string">    object and calling its listen method.  Keyword arguments not</span></span><br><span class="line"><span class="string">    supported by `HTTPServer.listen &lt;.TCPServer.listen&gt;` are passed to the</span></span><br><span class="line"><span class="string">    `.HTTPServer` constructor.  For advanced uses</span></span><br><span class="line"><span class="string">    (e.g. multi-process mode), do not use this method; create an</span></span><br><span class="line"><span class="string">    `.HTTPServer` and call its</span></span><br><span class="line"><span class="string">    `.TCPServer.bind`/`.TCPServer.start` methods directly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that after calling this method you still need to call</span></span><br><span class="line"><span class="string">    ``IOLoop.current().start()`` to start the server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns the `.HTTPServer` object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 4.3</span></span><br><span class="line"><span class="string">       Now returns the `.HTTPServer` object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    server = HTTPServer(self, **kwargs)  <span class="comment"># 把当前app和HttpServer进行绑定</span></span><br><span class="line">    server.listen(port, address)</span><br><span class="line">    <span class="keyword">return</span> server</span><br></pre></td></tr></tbody></table></figure><p>上面零零洒洒的注释大致也说明了这个<code>app.listen</code>是一个启动<code>HttpServer</code>的快捷方式。 但是提到了一句，如果需要使用多进程模式， 就不能使用当前这种方法了。 </p><p>当然， 使用了<code>app.listen</code>方法后还需要启动IO循环才算真正的启动了<code>http</code>服务器。</p><p>上面的<code>HTTPServer</code>内部这里先不进去深入探究， 后续再深入探究</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看看启动server的代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="tornado" scheme="http://example.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>简化版异步框架</title>
    <link href="http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/1-%E7%AE%80%E5%8C%96%E7%89%88%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2021/03/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/1-%E7%AE%80%E5%8C%96%E7%89%88%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境： 公司内部使用的web框架是基于tornado封装的， 为了快速熟悉框架与业务， 开始尝试阅读tornado源码， 来加速自己的成长。</p><h2 id="简化版的协程web框架"><a href="#简化版的协程web框架" class="headerlink" title="简化版的协程web框架"></a>简化版的协程web框架</h2><h3 id="简化版web框架核心代码"><a href="#简化版web框架核心代码" class="headerlink" title="简化版web框架核心代码"></a>简化版web框架核心代码</h3><p>来自《Python Cookbook》利用协程代替多线程来实现的网络并发框架，可以单线程执行多个网络请求的读和写。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">来源：Python cookbook， 使用协程模式来实现一个并发网络框架</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> select <span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This class represents a generic yield event in the scheduler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldEvent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Task Scheduler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._numtasks = <span class="number">0</span>  <span class="comment"># Total num of tasks</span></span><br><span class="line">        self._ready = deque()  <span class="comment"># Tasks ready to run</span></span><br><span class="line">        self._read_waiting = {}  <span class="comment"># Tasks waiting to read</span></span><br><span class="line">        self._write_waiting = {}  <span class="comment"># Tasks waiting to write</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Poll for I/O events and restart waiting tasks</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_iopoll</span>(<span class="params">self</span>):</span><br><span class="line">        rset, wset, eset = select(self._read_waiting,</span><br><span class="line">                                  self._write_waiting, [])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> rset:</span><br><span class="line">            evt, task = self._read_waiting.pop(r)</span><br><span class="line">            evt.handle_resume(self, task)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wset:</span><br><span class="line">            evt, task = self._write_waiting.pop(w)</span><br><span class="line">            evt.handle_resume(self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">self, task</span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Add a newly started task to the scheduler</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        self._ready.append((task, <span class="literal">None</span>))</span><br><span class="line">        self._numtasks += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_ready</span>(<span class="params">self, task, msg=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Append an already started task to the ready queue.</span></span><br><span class="line"><span class="string">        msg is what to send into the task when it resumes.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._ready.append((task, msg))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a task to the reading set</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">        self._read_waiting[fileno] = (evt, task)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a task to the write set</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_write_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">        self._write_waiting[fileno] = (evt, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Run the task scheduler until there are no tasks</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self._numtasks:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._ready:</span><br><span class="line">                self._iopoll()</span><br><span class="line">            task, msg = self._ready.popleft()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Run the coroutine to the next yield</span></span><br><span class="line">                r = task.send(msg)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(r, YieldEvent):</span><br><span class="line">                    r.handle_yield(self, task)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> RuntimeError(<span class="string">'unrecognized yield event'</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self._numtasks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example implementation of coroutine-based socket I/O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock, nbytes</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line">        self.nbytes = nbytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        data = self.sock.recv(self.nbytes)</span><br><span class="line">        sched.add_ready(task, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock, data</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._write_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        nsent = self.sock.send(self.data)</span><br><span class="line">        sched.add_ready(task, nsent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcceptSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        r = self.sock.accept()</span><br><span class="line">        sched.add_ready(task, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wrapper around a socket object for use with yield</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self._sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, maxbytes</span>):</span><br><span class="line">        <span class="keyword">return</span> ReadSocket(self._sock, maxbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> WriteSocket(self._sock, data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AcceptSocket(self._sock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._sock, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Example of a function involving generators.  This should</span></span><br><span class="line">    <span class="comment"># be called using line = yield from readline(sock)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">sock</span>):</span><br><span class="line">        chars = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            c = <span class="keyword">yield</span> sock.recv(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chars.append(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">b'\n'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b''</span>.join(chars)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Echo server using generators</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EchoServer</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, sched</span>):</span><br><span class="line">            self.sched = sched</span><br><span class="line">            sched.new(self.server_loop(addr))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">server_loop</span>(<span class="params">self, addr</span>):</span><br><span class="line">            s = Socket(socket(AF_INET, SOCK_STREAM))</span><br><span class="line"></span><br><span class="line">            s.bind(addr)</span><br><span class="line">            s.listen(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                c, a = <span class="keyword">yield</span> s.accept()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'Got connection from '</span>, a)</span><br><span class="line">                self.sched.new(self.client_handler(Socket(c)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">client_handler</span>(<span class="params">self, client</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                line = <span class="keyword">yield</span> <span class="keyword">from</span> readline(client)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                line = <span class="string">b'GOT:'</span> + line</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'line: '</span>, line)</span><br><span class="line">                <span class="keyword">while</span> line:</span><br><span class="line">                    nsent = <span class="keyword">yield</span> client.send(line)</span><br><span class="line">                    line = line[nsent:]</span><br><span class="line">            client.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Client closed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    EchoServer((<span class="string">''</span>, <span class="number">16000</span>), sched)</span><br><span class="line">    sched.run()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h3><p>上面代码总共分为以下几部分， 分别定义了任务调度器， 任务调度器调度的任务格式（事先定义了<code>YieldEvent</code>接口， 后续有3个实现类）， 简易的echo服务器。 </p><p>上面几个模块， 接下来跟随代码的启动来一一分析。</p><h4 id="框架启动"><a href="#框架启动" class="headerlink" title="框架启动"></a>框架启动</h4><p>main函数里首先定义了一个核心的任务调度器 <code>    sched = Scheduler()</code>。</p><p>这个任务调度器初始化了几个核心组件。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._numtasks = <span class="number">0</span>  <span class="comment"># Total num of tasks， 调度器中的总任务数</span></span><br><span class="line">        self._ready = deque()  <span class="comment"># Tasks ready to run ， 已经就绪的任务， 放在双端队列中</span></span><br><span class="line">        self._read_waiting = {}  <span class="comment"># Tasks waiting to read， 准备读的任务</span></span><br><span class="line">        self._write_waiting = {}  <span class="comment"># Tasks waiting to write， 准备写的任务</span></span><br></pre></td></tr></tbody></table></figure><p>然后通过<code> EchoServer(('', 16000), sched)</code>定义了一个应用服务器, 这里面只做了两个操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, sched: Scheduler</span>):</span><br><span class="line">    self.sched = sched  // 绑定刚刚的调度器，</span><br><span class="line">    sched.new(self.server_loop(addr))  // 创建一个就绪任务到调度器中</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">self, task</span>):</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Add a newly started task to the scheduler</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">self._ready.append((task, <span class="literal">None</span>))   // 将已经开始的任务放到就绪队列中</span><br><span class="line">self._numtasks += <span class="number">1</span>  // 调度器中任务数+<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>上面的第一个任务（服务器主循环协程）等到下面再说明。</p><p>最后一行执行的是<code>sched.run()</code>， 通过这行代码调度器正式开始启动。</p><p>接下来分析这个<code>run</code>方法。</p><h4 id="sche-run"><a href="#sche-run" class="headerlink" title="sche.run"></a>sche.run</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Run the task scheduler until there are no tasks</span></span><br><span class="line"><span class="string">        运行任务调度器直到没有任务</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 但存在任务的时候执行循环</span></span><br><span class="line">        <span class="keyword">while</span> self._numtasks:                  <span class="comment"># 1</span></span><br><span class="line">            <span class="comment"># 有准备运行的任务</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._ready:                <span class="comment"># 2</span></span><br><span class="line">                <span class="comment"># 执行iopoll的</span></span><br><span class="line">                self._iopoll()                 <span class="comment"># 3</span></span><br><span class="line">            task, msg = self._ready.popleft()  <span class="comment"># 4</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Run the coroutine to the next yield</span></span><br><span class="line">                <span class="comment"># 运行协程直到下一个yield</span></span><br><span class="line">                r = task.send(msg)             <span class="comment"># 5</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(r, YieldEvent):</span><br><span class="line">                    r.handle_yield(self, task) <span class="comment"># 6</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> RuntimeError(<span class="string">'unrecognized yield event'</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self._numtasks -= <span class="number">1</span>            <span class="comment"># 7</span></span><br></pre></td></tr></tbody></table></figure><p>从代码结构看出来， 调度器是通过循环的方式， 循环的执行自己已经就绪的任务， 当没有就绪任务的时候， 就去执行IO循环。</p><p>接下来模拟程序运行的过程。</p><h6 id="第一轮主循环"><a href="#第一轮主循环" class="headerlink" title="第一轮主循环"></a>第一轮主循环</h6><p>从 #1处看出， 调度器是根据内部可以执行的任务数量来进行判断的， 当内部任务有任务时， 循环就不会结束， 这就是网络框架的主循环。</p><h6 id="判断是否有可以执行的任务"><a href="#判断是否有可以执行的任务" class="headerlink" title="判断是否有可以执行的任务"></a>判断是否有可以执行的任务</h6><p>起初自己的任务队列中是有值的， 在初始化过程中添加了一个<code>(server_loop(), None)</code>的任务到队列中。</p><h6 id="取出可以执行的任务"><a href="#取出可以执行的任务" class="headerlink" title="取出可以执行的任务"></a>取出可以执行的任务</h6><p>#4 这步取出协程任务本身和msg消息， 相当于解码了上面添加的<code>(server_loop(), None)</code>。 这里也是取出了任务队列中唯一的任务。</p><h6 id="启动生成器"><a href="#启动生成器" class="headerlink" title="启动生成器"></a>启动生成器</h6><p><code>server_loop()</code>本身是一个生成器， 在这里也可以称之为协程。他本身并未启动， 需要通过当前的主循环来驱动它执行。 #5 步操作就是启动这个生成器， 相当于<code>server_loop().send(None)</code>， 这是Python的基础语法， 会执行到生成器的第一处yield， 并返回第一个yield值（<code>s.accept()</code>）。</p><p>下面是这个server_loop生成器的内容</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server_loop</span>(<span class="params">self, addr</span>):</span><br><span class="line">    s = Socket(socket(AF_INET, SOCK_STREAM))</span><br><span class="line"></span><br><span class="line">    s.bind(addr)</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c, a = <span class="keyword">yield</span> s.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Got connection from '</span>, a)</span><br><span class="line">        self.sched.new(self.client_handler(Socket(c)))</span><br></pre></td></tr></tbody></table></figure><p>上面 #5 步 r的值就是上面<code>s.accpet()</code>返回的东西. 下面是这个Socket客户端的内部结构</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wrapper around a socket object for use with yield</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self._sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, maxbytes</span>):</span><br><span class="line">        <span class="keyword">return</span> ReadSocket(self._sock, maxbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> WriteSocket(self._sock, data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AcceptSocket(self._sock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._sock, name)</span><br></pre></td></tr></tbody></table></figure><p>可以看到其实<code>s.accept()</code>实际上就是一个 AcceptSocket()客户端。 </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AcceptSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        r = self.sock.accept()</span><br><span class="line">        sched.add_ready(task, r)</span><br></pre></td></tr></tbody></table></figure><p>AcceptSocket客户端初始化并没有做任何事， 只是把服务端的socket对象绑定上了。 </p><h6 id="调用handle-yield方法"><a href="#调用handle-yield方法" class="headerlink" title="调用handle_yield方法"></a>调用handle_yield方法</h6><p>这个网络框架规定任务调度器只会执行<code>YieldEvent</code>类型的任务。 而<code>YieldEvent</code>类规定了2个基础接口。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This class represents a generic yield event in the scheduler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldEvent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p><code>handle_yield</code>方法会在主循环中被调用，<code>handle_resume </code>会被<code>_iopoll</code>方法里面的副循环调用。</p><p>#6步骤执行了<code>AcceptSocket</code>实例对象的<code>handle_yield</code>方法， 它往调度器内部放入了sched._read_wait(self.sock.fileno(), self, task)</p><p>这里可以简单的看一下调度器内部的添加方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_ready</span>(<span class="params">self, task, msg=<span class="literal">None</span></span>):</span><br><span class="line">       <span class="string">'''</span></span><br><span class="line"><span class="string">       Append an already started task to the ready queue.</span></span><br><span class="line"><span class="string">       msg is what to send into the task when it resumes.</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">       self._ready.append((task, msg))</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Add a task to the reading set</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">_read_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">       self._read_waiting[fileno] = (evt, task)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Add a task to the write set</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">_write_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">       self._write_waiting[fileno] = (evt, task)</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到在任务调度器的_read_waiting字典中放入了{sock.fileno()： （AcceptSocket类实例对象, 上面启动了的server_loop生成器）}， 这时候框架实际上是把对客户端的监听让底层的select机制来进行监控， 网络框架不会去管这些， 这才是异步的主要原因。 </p><p>现在第一轮主循环进行完毕。 </p><p>这时候调度器中的状态是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._numtasks       <span class="comment"># = 1，服务器启动时进行了加1</span></span><br><span class="line">self._ready          <span class="comment"># 空</span></span><br><span class="line">self._read_waiting   <span class="comment"># {sock.fileno():(AcceptSocket类实例对象, 上面启动了的server_loop生成器)}，可以托管给select了</span></span><br><span class="line">self._write_waiting  <span class="comment"># 空</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第二轮主循环"><a href="#第二轮主循环" class="headerlink" title="第二轮主循环"></a>第二轮主循环</h6><p>服务器是永久执行的，所以调度器中的任务数永远至少为1， 所以主循环可以认为是无限循环的。 </p><h6 id="判断是否有可以执行的任务-1"><a href="#判断是否有可以执行的任务-1" class="headerlink" title="判断是否有可以执行的任务"></a>判断是否有可以执行的任务</h6><p>现在self._ready队列是空的， 所以去执行 <code>self._iopoll()</code>这个分支的代码。</p><h6 id="IO循环"><a href="#IO循环" class="headerlink" title="IO循环"></a>IO循环</h6><p>iopoll()方法可以暂时想象成tornado中的IO循环， 下面看一下IO循环内部干了写什么。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Poll for I/O events and restart waiting tasks</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_iopoll</span>(<span class="params">self</span>):</span><br><span class="line">    rset, wset, eset = select(self._read_waiting,</span><br><span class="line">                              self._write_waiting, [])</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> rset:</span><br><span class="line">        evt, task = self._read_waiting.pop(r)</span><br><span class="line">        evt.handle_resume(self, task)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> wset:</span><br><span class="line">        evt, task = self._write_waiting.pop(w)</span><br><span class="line">        evt.handle_resume(self, task)</span><br></pre></td></tr></tbody></table></figure><p>select方法是实现IO多路复用的基本方法之一， 这里的意思是把需要监听的读写文件描述符让select模块帮忙监听， 当有读写事件就绪了， select方法就会返回rset和wset， eset是出现异常的集合。</p><p>select默认是阻塞的， 当没有套接字状态发生变化的情况下， 这个方法会一直堵塞。</p><h6 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h6><p>现在假设当有一个客户端请求后， select函数立刻返回， 然后执行下面的<code> evt, task = self._read_waiting.pop(r)</code>语句， evt和task分别是AcceptSocket实例对象和serverLoop生成器对象。</p><p>接下来执行<code> evt.handle_resume(self, task)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">    r = self.sock.accept()</span><br><span class="line">    sched.add_ready(task, r)</span><br></pre></td></tr></tbody></table></figure><p>原本sock.accept()是堵塞的， 现在把这个堵塞时间交由系统提供的select机制来监控， 现在有读事件， 表明accept()方法可以立即返回。 这个r返回的是socket接收到客户端client和客户端的ip，端口信息元组。现在把这个信息重新加入到任务调度器的任务队列中。 </p><p>IO循环执行完毕， 接下来回到主循环， 立即会取出刚刚放入的serverLoop生成器和sock.accept()接收到的信息。</p><p>然后运行#5步， 执行<code>server_loop().send(sock.accept())</code>，server_loop生成器继续运行。</p><p>生成器执行yield之后的代码， 并接收客户端和ip信息</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c, a = <span class="keyword">yield</span> s.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Got connection from '</span>, a)</span><br><span class="line">    self.sched.new(self.client_handler(Socket(c)))</span><br></pre></td></tr></tbody></table></figure><p>执行完之后， 调用调用任务调度器， 添加新的就绪任务， 表明可以等待处理客户端的请求信息了。 </p><p>处理客户端请求又是一个生成器(协程)</p><p>代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">client_handler</span>(<span class="params">self, client</span>):</span><br><span class="line">           <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">               line = <span class="keyword">yield</span> <span class="keyword">from</span> readline(client)</span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">               line = <span class="string">b'GOT:'</span> + line</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">'line: '</span>, line)</span><br><span class="line">               <span class="keyword">while</span> line:</span><br><span class="line">                   nsent = <span class="keyword">yield</span> client.send(line)</span><br><span class="line">                   line = line[nsent:]</span><br><span class="line">           client.close()</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">'Client closed'</span>)</span><br></pre></td></tr></tbody></table></figure><p>现在任务队列里面就有了一个(client_handler(Socket(socket)，None)的信息， 但是对于框架来说， 此时虽然知道有一个请求需要处理，但是并没有直接去处理这个请求， 而是需要重新在调度器空闲的重新去接收新的客户端请求。接下来重新执行<code>AcceptSocket</code>实例对象的<code>handle_yield</code>方法， 然后重复上面之前的操作。</p><p>现在第二轮主循环结束</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._numtasks       <span class="comment"># = 2，一个服务器任务，一个客户端请求处理任务</span></span><br><span class="line">self._ready          <span class="comment"># [(client_handler(Socket(clientSocket)，None)]</span></span><br><span class="line">self._read_waiting   <span class="comment"># {sock.fileno():(AcceptSocket类实例对象, 之前的server_loop生成器)}，可以托管给select了</span></span><br><span class="line">self._write_waiting  <span class="comment"># 空</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第三轮主循环"><a href="#第三轮主循环" class="headerlink" title="第三轮主循环"></a>第三轮主循环</h6><p>任务调度器开始处理第一个客户端的请求， #4 run方法取出的第一个任务是客户端的请求， 即(client_handler(Socket(clientSocket)，None)， 然后启动客户端请求处理生成器。</p><p>客户端的处理也是比较复杂的， 会先执行完readline(client)这个生成器内的内容， 然后才往下执行。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of a function involving generators.  This should</span></span><br><span class="line">    <span class="comment"># be called using line = yield from readline(sock)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">sock</span>):</span><br><span class="line">        chars = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            c = <span class="keyword">yield</span> sock.recv(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chars.append(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">b'\n'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b''</span>.join(chars)</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个生成器是返回Socket对象的recv(1)的结果， 从下面代码可以看出是返回ReadSocket对象</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self._sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, maxbytes</span>):</span><br><span class="line">        <span class="keyword">return</span> ReadSocket(self._sock, maxbytes)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Example implementation of coroutine-based socket I/O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock, nbytes</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line">        self.nbytes = nbytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        data = self.sock.recv(self.nbytes)</span><br><span class="line">        sched.add_ready(task, data)   </span><br></pre></td></tr></tbody></table></figure><p>上述代码相当于run方法中#5 r返回的是这个ReadSocket对象， 然后执行#6 的handle_yield方法。 相当于执行<code>ReadSocket(1).handle_yield(sche, client_handler())</code>, 然后把处理连接客户端的socket的文件描述符放到_read_waiting字典中。 </p><p>这样， 第三轮主循环就结束了。 </p><p>当前调度器中的状态如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._numtasks       <span class="comment"># = 2，一个服务器任务，一个客户端请求处理任务</span></span><br><span class="line">self._ready          <span class="comment"># 空</span></span><br><span class="line">self._read_waiting   <span class="comment"># {sock.fileno():(AcceptSocket类实例对象, 之前的server_loop生成器)， sock.fileno():(ReadSocket类实例对象, 启动了的client_handler生成器)}，这里的两个sock.fileno()不是同一个东西， 一个是启动的服务起用来监听客户端连接的socket， 一个是处理第一个客户端连接请求的clientSocket</span></span><br><span class="line">self._write_waiting  <span class="comment"># 空</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第四轮循环"><a href="#第四轮循环" class="headerlink" title="第四轮循环"></a>第四轮循环</h6><p>接下来由于_ready为空， 回去执行IO循环。 由于此时等待读的套接字有两个， 可能有新的请求进来或是客户端发来了信息等待读取， 为了讨论方便， 接下来只考虑只有一个客户端。 那么接下来需要处理客户端的读消息。 那么会去执行   ReadSocket的handle_resume方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">    data = self.sock.recv(self.nbytes)</span><br><span class="line">    sched.add_ready(task, data)   </span><br></pre></td></tr></tbody></table></figure><p>这里只读取了一个字节， 然后重新在队列中加入（client_handler， data）数据， 然后在#4步中取出， 然后会在#6步中驱动client_handler这个生成器继续执行， 进而驱动readline这个生成器执行。 client_handler.send(data), 这里的data只有一个字节数据。 最后返回一个新的readsocket对象， 然后主循环执行handle_yield方法， 然后进入IO循环执行handle_resume方法， 继而一直循环， 直至readline生成器执行完成。 </p><h6 id="写事件"><a href="#写事件" class="headerlink" title="写事件"></a>写事件</h6><p>读一行完毕后， 接下来就会去执行发送事件， </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">                   nsent = <span class="keyword">yield</span> client.send(line)</span><br><span class="line">                   line = line[nsent:]</span><br></pre></td></tr></tbody></table></figure><p>每次发送nsent个字节， 这个逻辑和上面的读逻辑基本一样， 就不赘述了。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.zhihu.com/column/tornado">知乎大神的Tornado源码阅读记录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境： 公司内部使用的web框架是基于tornado封装的， 为了快速熟悉框架与业务， 开始尝试阅读tornado源码， 来加速自己的成长。&lt;/p&gt;
&lt;h2 id=&quot;简化版的协程web框架&quot;&gt;&lt;a href=&quot;#简化版的协程web框架&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="python" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/python/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="tornado" scheme="http://example.com/tags/tornado/"/>
    
  </entry>
  
</feed>
