<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yscl的个人笔记</title>
  
  <subtitle>个人笔记</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-13T06:01:05.294Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yscl</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录crontab定时器任务重启失败问题</title>
    <link href="http://example.com/2022/09/13/linux/crontab%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5/"/>
    <id>http://example.com/2022/09/13/linux/crontab%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%90%AF%E5%A4%B1%E8%B4%A5/</id>
    <published>2022-09-12T16:00:00.000Z</published>
    <updated>2022-09-13T06:01:05.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录crontab定时器任务重启失败问题"><a href="#记录crontab定时器任务重启失败问题" class="headerlink" title="记录crontab定时器任务重启失败问题"></a>记录crontab定时器任务重启失败问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>由于客户那边的服务器环境需要开启vpn才能连接位于其他内网环境的数据库, 但是这个vpn长期连接并不稳定. 于是我就想起使用crontab 来定时重启. </p><p>定时器任务书写为下所示: 每两天的0点15分来进行重启</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 0 */2 * * /root/restart_vpn.sh</span><br></pre></td></tr></tbody></table></figure><p>想法并没有错误, 但是该定时任务并没有执行成功. 而我手动执行该脚本是可以成功的. </p><p>这就需要进行失败原因排查.</p><p>下面是写的<code>restart.sh</code>的内容</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep vpn.sh | grep -v grep | awk <span class="string">'{print $2}'</span> | xargs <span class="built_in">kill</span> -9</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"start restart?"</span> &gt;&gt; /root/restart_vpn.log</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nohup /root/vpn.sh &amp;"</span> | bash;</span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"success restart!"</span> &gt;&gt; /root/restart_vpn.log</span><br></pre></td></tr></tbody></table></figure><p>经过最终的仔细排查, 原来是我kill掉的进程中包括 定时任务执行的restart_vpn.sh本身. 因此最后还没有把脚本完全执行完全, 就kill掉自身了. 只需要重命名restart脚本名字即可. </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次错误原因本身很简单. 但是排查还真的不容易,  因为上面脚本我直接执行是不会出现任何错误的, 但是交由定时器来执行就会出错. 归根结底还是自己的不细致导致的, 至此记录以下修复bug以警示自己.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记录crontab定时器任务重启失败问题&quot;&gt;&lt;a href=&quot;#记录crontab定时器任务重启失败问题&quot; class=&quot;headerlink&quot; title=&quot;记录crontab定时器任务重启失败问题&quot;&gt;&lt;/a&gt;记录crontab定时器任务重启失败问题&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="个人记录" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>shell安装vim 8.2</title>
    <link href="http://example.com/2022/06/02/linux/%E5%AE%89%E8%A3%85vim%20shell/"/>
    <id>http://example.com/2022/06/02/linux/%E5%AE%89%E8%A3%85vim%20shell/</id>
    <published>2022-06-01T16:00:00.000Z</published>
    <updated>2022-09-13T06:01:05.274Z</updated>
    
    <content type="html"><![CDATA[<p>安装vim shell</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y libncurses5-dev libgnome2-dev libgnomeui-dev \</span><br><span class="line">    libgtk2.0-dev libatk1.0-dev libbonoboui2-dev \</span><br><span class="line">    libcairo2-dev libx11-dev libxpm-dev libxt-dev python-dev \</span><br><span class="line">    python3-dev build-essential cmake git</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个可以选择不安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt-get install -y golang</span></span><br><span class="line"></span><br><span class="line">echoo "&gt;&gt;&gt; Remove vim if you have it already ..."</span><br><span class="line">sudo apt-get remove -y vim vim-runtime gvim</span><br><span class="line"></span><br><span class="line">echoo "&gt;&gt;&gt; Install vim ..."</span><br><span class="line">cd ~ &amp;&amp; rm -rf vim &amp;&amp; git clone --branch v8.2.0114 --depth=1 https://github.com/vim/vim.git &amp;&amp; cd vim</span><br><span class="line"></span><br><span class="line">./configure --with-features=huge \</span><br><span class="line">    --enable-multibyte \</span><br><span class="line">    --enable-rubyinterp=yes \</span><br><span class="line">    --enable-pythoninterp=yes \</span><br><span class="line">    --enable-python3interp=yes \</span><br><span class="line">    --enable-perlinterp=yes \</span><br><span class="line">    --enable-luainterp=yes \</span><br><span class="line">    --enable-gui=gtk2 \</span><br><span class="line">    --enable-cscope \</span><br><span class="line">    --prefix=/usr/local</span><br><span class="line">make VIMRUNTIMEDIR=/usr/local/share/vim/vim82</span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安装vim shell&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>java一些基础内容记录</title>
    <link href="http://example.com/2022/03/05/java/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2022/03/05/java/%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</id>
    <published>2022-03-04T16:00:00.000Z</published>
    <updated>2022-09-13T06:01:05.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="Exception和RuntimeException的区别"><a href="#Exception和RuntimeException的区别" class="headerlink" title="Exception和RuntimeException的区别"></a><strong>Exception和RuntimeException的区别</strong></h4><p>使用RuntimeException的话, service可以不用抛出异常, 而可以在全局统一捕获. </p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>xml大于小于号的书写需要使用转义符号</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>jvm启动参数配置含义</p><h3 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h3><p>压测工具的使用</p><p>tps和qps区别.  tps是用户一次操作向服务器每秒的响应能力, 可能会请求多个接口, qps是访问一个接口服务的相应能力</p><p>添加cookie: 直接复制浏览器的cookie到cookie管理器中</p><p>阿里云部署方案设计</p><p>只开通一台nginx服务器公网, mysql,redis服务器在同一台服务器上.  应用服务器和redis都不可以访问外网, 不同实例之间配置内网安全组规则进行相互访问. </p><p>配置多个自动部署脚本, 实现自动部署.</p><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>redis缓存  </p><p>热点内存缓存(本地热点缓存)  这个也是二级缓存</p><pre><code>+ 热点数据+ 脏读不敏感+ 内存可控 (一般存在周期比较短)</code></pre><p>nginx proxy cache缓存 nginx自带的缓存是基于文件系统的,速度还是比较慢</p><p>nginx lua缓存</p><p>​nginx的执行阶段或者说生命周期. 可以参考</p><pre><code>+ https://www.jianshu.com/p/da7a6e628bb4+ https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html#02-NginxDirectiveExecOrder02</code></pre><p>nginx 自带的sharedict缓存</p><p>nginx redis</p><h3 id="HTTP-cache-control"><a href="#HTTP-cache-control" class="headerlink" title="HTTP cache control"></a>HTTP cache control</h3><p>非常好的讲解文章: <a href="https://blog.techbridge.cc/2017/06/17/cache-introduction/">https://blog.techbridge.cc/2017/06/17/cache-introduction/</a></p><p>和http cache相关的header有Cache-Control<code>, </code>Etag<code>, </code>Last-Modified<code>, </code>Expires等等. 这些都是控制资源缓存的策略与时间. </p><p>cache control响应头的值:</p><ul><li>private  表示只有客户端可以进行缓存.</li><li>public 表示客户端和代理服务器都可以进行缓存. </li><li>max-age: 表示可以缓存的时间</li><li>no-store: 客户端不缓存资源, 每次都从服务器中进行获取. </li><li>no-cache: 这个命名有点歧义, 它表示会缓存响应. 但是会和etag标签进行一块使用, 每次请求资源会带上etag标签询问服务器文件是否有进行更改过. 如果没有, 服务器会返回304 NOT MODIFIED. 表示客户端可以使用本地缓存. 这个策略是用来解决那些需要客户端及时更新本地资源, 又能可以减少服务器带宽的一种策略.</li></ul><p>http1.0 有一个Expires请求头, 这个字段就是控制缓存过期的时间.  但是这个字段和客户端的系统时间强绑定, 后来http1.1就出现了max-age这个投. 当这两个字段同时出现的时候, 以max-age为准. </p><p>但是即使定义了这两个字段之后, 当缓存过期后也不代表不能继续使用. 所以又定义了Last-Modified 與 If-Modified-Since 两个字段. 当客户端缓存过期之后, 会带上If-Modified-Since这个字段询问服务器资源是否有更新过. 如果没有, 则返回304状态码. </p><p>但是这两个字段还是比较简单, 因为一个文件即使只是打开, 那么上次编辑时间也会改变, 那么这样也会浪费带宽重新传递一遍. 于是出现了Etag 與 If-None-Match这一对使用的请求头字段. </p><p>etag类似于文件的md5, 那么当客户端过期之后, 处理方式与之前的modified一致. </p><p>但是如果有需求, 既要节省带宽, 又想保证缓存的及时性. 那么可以使用max-age=0和etag标志一块使用, 每次请求服务询问是否有新的内容. 这个现在可以使用nocache标志来进行代替. </p><p>当然上面的nocache虽然节省了带宽, 但是毕竟还是存在网络请求的, 还可以有一种手段, 就是比如一个页面的js文件, 文件名直接以md5值进行命名, 那么当文件改变后, 资源路径变掉即可. 这样就可以配合之前的cache控制操作进而减少网络请求, 从而达到减少服务带宽的压力.  </p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>content delievery network  内容分发网络</p><p>静态资源cdn引入. </p><p>cdn可以理解为一个无限大容量的缓存. 当用户需要请求的静态文件在cdn上不存在的话, 那么就会触发回源操作, 即到应用服务器本地去寻找对应的资源文件. 然后就会把对应的文件重新缓存到cdn, cdn上可以设置资源的缓存周期等等策略. </p><p>阿里云cdn配置流程: </p><p>​现在cdn配置控制台添加一个子域名. 这个子域名会生成一个CNAME类型的解析类型. 然后需要到域名解析管理页面上添加一条记录CNAME为刚刚cdn生成的cdn. </p><p>​    域名记录类型有很多种, 一般是A类, 即指向一个ip地址. 即域名直接指代ip地址. 第二种则是CNAME类型. 即解析后返回新的CName类型, 交由这个cname去执行. </p><p><strong>CDN自定义缓存策略</strong></p><p>cdn的角色对应浏览器的服务端角色, 后端nginx等代理服务器的客户端角色, 配置缓存策略就比较重要了. </p><ul><li>自定义目录过期时间</li><li>自定义后缀过期的时间</li><li>自定义对应权重</li><li>通过api或者界面强制目录刷新(不一定成功)</li></ul><p>静态资源部署策略</p><p>js,css,img等资源文件使用hash值作为文件名, 那么当文件改完后,先部署完这些文件后,再部署html.  </p><p>这样更新后, 对应js等资源文件max-age就可以设置的很长. html文件可以设置no-cache或者较短的max-age. 便于及时的更新资源文件. </p><p>当然还可以把html设置较长的max-age, 但是需要后台ajax动态的获取html的版本号, 然后进行动态的刷新. </p><p>此外, 动态请求也可以静态化成json文件推送到cdn上, 但是这样可能会产生热更新等问题, 这就需要ajax后台异步获取最新版本号等信息, 动态的更新页面数据. </p><p><strong>全页面静态化</strong></p><p>在服务端完成html,css,甚至js的load渲染成纯html文件后直接以静态资源的方式部署到cdn上. </p><p>可以借助无头浏览器等工具将渲染完成的页面打包分发到cdn上. </p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><strong>PostConstruct</strong></p><h3 id="交易验证优化"><a href="#交易验证优化" class="headerlink" title="交易验证优化"></a>交易验证优化</h3><p><strong>用户风控策略优化</strong></p><p>基础的用户id存不存在, 用户最近是否更改过密码. 用户是否异地登录等等. </p><p><strong>活动策略优化</strong></p><p>活动发布流程: 只要在活动上线前一段时间发布即可</p><p>模型缓存化</p><p>还要有紧急下线能力. </p><p>扣减库存优化</p><p>扣减库存使用缓存</p><p>异步同步数据库</p><p>最终数据一致性</p><p>中间可能遇到的问题:</p><p>异步消息发送失败, 如何处理同步?</p><p>扣减操作失败如何处理消息</p><p>下单失败无法正确回滚库存(比如用户取消下单, 或者超时支付等等异常原因) redis消息也要正确的进行回滚.</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>mysql当执行增删改操作时, 会自动为涉及到的行加锁, 而且该行为只会针对索引列生效</p><p>博客参考:</p><p><a href="https://www.cnblogs.com/itdragon/p/8194622.html">https://www.cnblogs.com/itdragon/p/8194622.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/52879825">https://zhuanlan.zhihu.com/p/52879825</a></p><h3 id="springboot循环依赖"><a href="#springboot循环依赖" class="headerlink" title="springboot循环依赖"></a>springboot循环依赖</h3><p>service之间互相依赖导致循环依赖 2.6版本之后不会自动解决循环依赖问题, 需要手动解决.</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>rocketmq的安装使用.</p><p> 事务型消息, 分布式服务事务的两阶段提交</p><p>操作性流水数据</p><p>根据业务场景进行抉择</p><ul><li>宁可少卖, 不可超卖</li><li>宁可超卖, 不可少卖</li></ul><p>超时重试机制</p><p>rocketmq事务型消息原理.  两阶段提交+事务执行回查.</p><p>原理介绍: <a href="https://blog.csdn.net/a745233700/article/details/122656108">https://blog.csdn.net/a745233700/article/details/122656108</a></p><p><a href="https://juejin.cn/post/6844904193526857742">https://juejin.cn/post/6844904193526857742</a></p><p>两阶段提交,三阶段提交</p><p><strong><strong>TCC分布式事务</strong></strong></p><p><a href="https://segmentfault.com/a/1190000012534071">https://segmentfault.com/a/1190000012534071</a></p><p><a href="https://www.cnblogs.com/jajian/p/10014145.html">https://www.cnblogs.com/jajian/p/10014145.html</a></p><p><a href="https://www.cnblogs.com/Leo_wl/p/15507952.html">https://www.cnblogs.com/Leo_wl/p/15507952.html</a></p><p>saga事务:<a href="https://cloud.tencent.com/developer/article/1839642">https://cloud.tencent.com/developer/article/1839642</a></p><p><a href="https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/">https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/</a></p><p>秒杀令牌:</p><p>出现的原因是因为, 秒杀的校验逻辑和下单逻辑是耦合在一块, 而且校验逻辑是十分复杂的, 这会额外加大接口负载的压力.</p><p>这样就可以通过秒杀令牌这个概念, 来提前把校验等操作通过获取令牌的时候就做完校验. 参数合法就发放一个有具体失效的令牌. 最后秒杀接口只需要从缓存中获取这个令牌即可. 然后专心的做下单, 生成流水, 减库存的操作了. </p><p>这个方案的缺点: </p><h4 id="秒杀令牌"><a href="#秒杀令牌" class="headerlink" title="秒杀令牌"></a>秒杀令牌</h4><p>生成数量没有做限制, 当活动开始的时候, 大量用户的请求可能达到获取秒杀令牌上去了. 性能也没有多大提升</p><h4 id="秒杀大闸"><a href="#秒杀大闸" class="headerlink" title="秒杀大闸"></a>秒杀大闸</h4><p>基于单纯的秒杀令牌的权限, 所以可以控制秒杀令牌的数量的发放. 来做到限制总体秒杀的流量. </p><p>可以基于授权原理定制发放令牌的逻辑</p><p>用户的风控策略放到令牌的发放中. </p><p>库存的售罄判断可以通过令牌的大闸做判断. 当令牌发放完毕, 表示库存发放完成.</p><p>缺点: 如果库存设置比较多, 或者说多商品多库存, 这个模型还是限制能力较弱. </p><p>并发能力还是不够 . </p><h4 id="队列泄洪"><a href="#队列泄洪" class="headerlink" title="队列泄洪"></a>队列泄洪</h4><p>可以将发送消息,减库存等操作放到一个固定大小的队列里面去执行.  在本地可以使用线程池, 后面的请求会存储到队列里面, </p><p>分布式集中管理可以放到队列里面, 比如redis中. 当redis挂了后, 那么为了防止单点故障, 采用降级策略使用本地缓存.</p><h3 id="防刷策略"><a href="#防刷策略" class="headerlink" title="防刷策略."></a>防刷策略.</h3><p>验证码</p><p>限流原理</p><h4 id="防黄牛策略"><a href="#防黄牛策略" class="headerlink" title="防黄牛策略"></a>防黄牛策略</h4><p>传统:  session限制,  ip限制: 容易误伤</p><p>客户端加固, 加大刷子的难度. 限制h5的请求,甚至不放到h5上进行</p><p>令牌锁</p><p>漏桶算法</p><p>分布式会话持久性策略</p><ol><li>用户的登录信息保存到mysql中, 每次查询直接到mysql中进行查询. 效率性能最低</li><li>用户的登录信息保存到redis中. 效率更高, 但是因为redis是作为一个缓存数据库, 总觉得有点不靠谱. </li><li>上面两种联合使用, mysql备份一份, redis存储一份. 验证登录态信息的时候, 查询redis缓存即可, 这时候即使redis挂了, 因为有mysql备份, 也一样没有啥问题.</li></ol><p>上面第三种方案看似很完美, 其实缺陷也很大, 因为验证登录态这个操作几乎是大部分接口都需要进行调用的, 那么如果redis扛不住流量的并发, 那么就会瞬间打到mysql上, 那么redis都扛不住, mysql肯定瞬间也扛不住, 所以这个方案还是有很大的改进空间的.   所以这个方案的前提就是提高redis的高可用, 比如使用redis集群方案. </p><p>会话续命. </p><p>强登录态和弱登录态</p><p>强登录态: 接口一定需要知道用户的用户id信息, 一定需要登录, 比如商品的下单操作. </p><p>弱登录态:  比如商品推荐功能, 不关注是否登录, 如果没有登录则根据千人千面的算法优先推荐大众喜欢的商品, 然后给出一个临时会话session, 可以让游客继续浏览, 然后后续推荐也根据其浏览历史进行推荐. 然是这个会带来一个问题, 就是弱登录态也需要有一个session续命的问题, 防止到过session过期时间, 之前的浏览历史清空的问题.  这可以通过后端提供接口, 然后前端发送请求续命或者前端启用定时器定时续命. </p><p>如果已经登录了, 则进行分析, 推荐个人可能喜欢的商品. </p><p>sso单点登录</p><p>单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><ul><li>同域名</li></ul><p>同域名非常好解决, 比如有两个应用一个是a.com/web/…   还有一个是a.com/web/phone/… 那么如果一个用户需要访问这两个APP应用资源的话, 由于是同源, 天生支持, 不会做任何限制. 也不用关注单点登录sso的问题.  </p><ul><li>根域名相同, 子域名不同, 登陆时候设置顶级域名即可</li></ul><p>后台设置返回时候设置 set-cookie: domain:/即可. 这样即可让所有属于统一根域名的共享cookie</p><p>后台设置cookie的时候, </p><ul><li>根域名也不相同.</li></ul><p><a href="https://cloud.tencent.com/developer/article/1552789">https://cloud.tencent.com/developer/article/1552789</a></p><p><a href="https://zhuanlan.zhihu.com/p/334720992">https://zhuanlan.zhihu.com/p/334720992</a></p><h3 id="cookie设置安全性"><a href="#cookie设置安全性" class="headerlink" title="cookie设置安全性"></a>cookie设置安全性</h3><h4 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h4><p><a href="https://segmentfault.com/a/1190000022235530">https://segmentfault.com/a/1190000022235530</a></p><p>防止js获取cookie, 可以防止xss脚本攻击.</p><p>SameSite: </p><p>Strict 只允许同站请求携带 Cookie。比如 lilnong.top 跳转到 <a href="http://www.lilnong.top/cors/%EF%BC%8C%E5%B0%B1%E5%B1%9E%E4%BA%8E%E5%90%8C%E7%AB%99%E3%80%82">www.lilnong.top/cors/，就属于同站。</a><br>Lax（chrome 80 后的默认值） 允许部分第三方请求场景 携带Cookie。<br>None（chrome 80 前的默认值） 无论是否跨站都会发送 Cookie。必须同时加上 Secure 属性，否则无效，也就是说只支持 HTTPS。</p><p>通用性能优化原理</p><p>缓存</p><p>异步</p><p>批处理</p><p>mysql单机优化</p><p>max-connection = 1000</p><p>innodb_file_per_table = 1</p><p>InnoDB_Buffer_Pool_size = 1G</p><p>innodb_log_file_size = 256M</p><p>innodb_log_buffer_size = 16M  <a href="https://zhuanlan.zhihu.com/p/65811829">https://zhuanlan.zhihu.com/p/65811829</a></p><p>innodb_flush_log_at_trx_commit = 2   配置[mysql_safe]节点上</p><p><a href="https://www.cnblogs.com/kevingrace/p/10441086.html">https://www.cnblogs.com/kevingrace/p/10441086.html</a></p><p>innodb_data_file_path=ibdata1:1G;ibdata2:1G;</p><p>redo 重做操作,  undo回滚操作</p><h3 id="mysql多主多从"><a href="#mysql多主多从" class="headerlink" title="mysql多主多从"></a>mysql多主多从</h3><p><strong>数据分片</strong></p><p>一般是根据sharding key + hash  + mod 的方式</p><p><strong>分片维度</strong></p><p>原则: 尽量让分片后数据的查询只落到一个数据库中. 而不要横跨多个库进行查询. 比如非sharding key的范围查询, 那么这种情况一般是用es来代替的.  </p><p><strong>sharding key:</strong> </p><p>固定路由库. 比如固定id</p><p>时间自增分片. </p><p><strong>分片冗余一致性的保障</strong></p><p><strong>无迁移扩展</strong></p><p>弹性迁移, 可以额外通过一个时间戳的方式, 让某个节点之前的数据还是按照之前的逻辑进行分库, 之后的数据按照新的分库规则路由. </p><p>如果类似userid带有时间戳的属性的话, 就可以按照上面的策略实现无迁移扩展.</p><p>分库分表之后的查询问题: </p><p><a href="https://segmentfault.com/a/1190000037776663">https://segmentfault.com/a/1190000037776663</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h3&gt;&lt;h4 id=&quot;Exception和RuntimeException的区别&quot;&gt;&lt;a href=&quot;#Exception和RuntimeExcepti</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="java" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>链路追踪链接集合</title>
    <link href="http://example.com/2021/10/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <id>http://example.com/2021/10/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</id>
    <published>2021-10-16T16:00:00.000Z</published>
    <updated>2022-09-13T06:15:52.869Z</updated>
    
    <content type="html"><![CDATA[<p>open-telemetry: <a href="https://github.com/open-telemetry/docs-cn/blob/main/specification/trace/sdk.md">https://github.com/open-telemetry/docs-cn/blob/main/specification/trace/sdk.md</a></p><p><a href="https://alovn.cn/docs/opentelemetry/quickstart.html">https://alovn.cn/docs/opentelemetry/quickstart.html</a></p><p><a href="https://izsk.me/2021/10/27/OpenTelemetry-Introduct/">https://izsk.me/2021/10/27/OpenTelemetry-Introduct/</a></p><p><a href="https://dmathieu.com/articles/development/dissecting-opentelemetry-tracing/">https://dmathieu.com/articles/development/dissecting-opentelemetry-tracing/</a></p><p><a href="https://www.bookstack.cn/read/goframe-1.16-zh/549208391059b05d.md">https://www.bookstack.cn/read/goframe-1.16-zh/549208391059b05d.md</a></p><p><a href="https://jckling.github.io/2021/04/02/Jaeger/OpenTelemetry%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB/">https://jckling.github.io/2021/04/02/Jaeger/OpenTelemetry%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB/</a></p><p>从grpc的meta数据中从carrier中获取span traceid等信息</p><p><a href="https://www.daimajiaoliu.com/daima/4796d27759003e4">https://www.daimajiaoliu.com/daima/4796d27759003e4</a></p><p>grpc通过metadata进行client和server端的数据传递. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;open-telemetry: &lt;a href=&quot;https://github.com/open-telemetry/docs-cn/blob/main/specification/trace/sdk.md&quot;&gt;https://github.com/open-telemetr</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="远程连接" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>gprc连接过程简单查看</title>
    <link href="http://example.com/2021/09/14/grpc/grpc%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2021/09/14/grpc/grpc%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/</id>
    <published>2021-09-13T16:00:00.000Z</published>
    <updated>2022-09-13T06:04:36.462Z</updated>
    
    <content type="html"><![CDATA[<p>grpc配合bilibili-discover的整个连接过程. </p><p>假设现在已经起了一个服务端到发现中心了. 现在需要在commet app从discover中获取到ip信息, 并正确的连接. </p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>首先需要创建注册发现中心. 这步有两个作用, 一个是获取注册中心的所有节点信息. 根据注册发现中心节点是否发生变化来更新原先配置文件中写的默认的配置中心(这里要求默认的配置中心一定要有一个是正确的地址, 不然无法获取到正确的配置中心).   第二个是注册discover的scheme到grpc的scheme map中. 后面的客户端需要根据发现中心的scheme来调用正确的解析方法, 然后根据appid来解析出来正确的对应服务端urls. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register discovery</span></span><br><span class="line">dis := naming.New(conf.Conf.Discovery)</span><br><span class="line">resolver.Register(dis)</span><br><span class="line">                  ↓</span><br><span class="line"><span class="comment">// 注册函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(b naming.Builder)</span></span> {</span><br><span class="line">resolver.Register(&amp;Builder{b})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的Builder实现了grpc 中的resolver.Builder接口. 在grpc.DialContext()方法中需要根据scheme来解析. 会调用自己实现的Build方法. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> Build(target resolver.Target, cc resolver.ClientConn, opts resolver.BuildOption) (resolver.Resolver, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// discovery://default/service.name?zone=sh001&amp;cluster=c1&amp;cluster=c2&amp;cluster=c3</span></span><br><span class="line">dsn := strings.SplitN(target.Endpoint, <span class="string">"?"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dsn) == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"grpc resolver: parse target.Endpoint(%s) failed! the endpoint is empty"</span>, target.Endpoint)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// parse params info</span></span><br><span class="line">zone := os.Getenv(<span class="string">"ZONE"</span>)</span><br><span class="line">clusters := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>{}{}</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dsn) == <span class="number">2</span> {</span><br><span class="line"><span class="keyword">if</span> u, err := url.ParseQuery(dsn[<span class="number">1</span>]); err == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">if</span> zones := u[naming.MetaZone]; <span class="built_in">len</span>(zones) &gt; <span class="number">0</span> {</span><br><span class="line">zone = zones[<span class="number">0</span>]</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> u[naming.MetaCluster] {</span><br><span class="line">clusters[c] = <span class="keyword">struct</span>{}{}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">r := &amp;Resolver{</span><br><span class="line">cc:       cc,   <span class="comment">// 调用grpc连接方法时返回的对象</span></span><br><span class="line">nr:       b.Builder.Build(dsn[<span class="number">0</span>]),  <span class="comment">// 在这里是调用一开始创建注册发现结构体对象的build方法, 这个返回对象使用来解析从注册中心获取到地址列表的信息的. 并只关注对应的appid相关的变化. 里面会实际开启协程去拉取注册的实例地址. </span></span><br><span class="line">quit:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">1</span>),   <span class="comment">// 退出信息, 后面关闭需要使用. </span></span><br><span class="line">zone:     zone,</span><br><span class="line">clusters: clusters,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">go</span> r.watcher()</span><br><span class="line"><span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是discover客户端的Build方法.  这个方法会创建一个resolver结构体. 然后会开启一个协程去监听自己需要连接的服务端对应的地址变化情况, 并及时更新连接信息. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Resolver)</span></span> watcher() {</span><br><span class="line">    <span class="comment">// 解析从注册中心拉取信息后进行通知的channel. </span></span><br><span class="line">event := r.nr.Watch()</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-r.quit:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 阻塞到有信号通知, 然后更新地址信息以及后续的更新grpc连接..</span></span><br><span class="line"><span class="keyword">case</span> _, ok := &lt;-event:</span><br><span class="line"><span class="keyword">if</span> !ok {</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 从当前app的discover对象中存储的apps字典对象中获取自己关注的appid对应的实例地址信息. </span></span><br><span class="line">ins, ok := r.nr.Fetch()</span><br><span class="line"><span class="keyword">if</span> ok {</span><br><span class="line">instances, ok := ins.Instances[r.zone]</span><br><span class="line"><span class="keyword">if</span> !ok {</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> ins.Instances {</span><br><span class="line">instances = <span class="built_in">append</span>(instances, value...)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(instances) &gt; <span class="number">0</span> {</span><br><span class="line">                <span class="comment">// 更新地址信息</span></span><br><span class="line">r.newAddress(instances)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Resolver)</span></span> newAddress(instances []*naming.Instance) {</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">totalWeight <span class="type">int64</span></span><br><span class="line">addrs       = <span class="built_in">make</span>([]resolver.Address, <span class="number">0</span>, <span class="built_in">len</span>(instances))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> n, ins := <span class="keyword">range</span> instances {</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.clusters) &gt; <span class="number">0</span> {</span><br><span class="line"><span class="keyword">if</span> _, ok := r.clusters[ins.Metadata[naming.MetaCluster]]; !ok {</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 这一步是解析从注册中心拉取的地址, 类似grpc://192.168.33.186:3119的形式. </span></span><br><span class="line">        <span class="comment">// 同时解析蓝绿, 权重, 更新权重信息等. 后面自己可以根据这些特殊信息来控制流量的分布. </span></span><br><span class="line">rpcAddr, color, weight := extractAddrs(ins)</span><br><span class="line"><span class="keyword">if</span> rpcAddr == <span class="string">""</span> {</span><br><span class="line">log.Warningf(<span class="string">"grpc resolver: invalid rpc address(%s,%s,%v) found!"</span>, ins.AppID, ins.Hostname, ins.Addrs)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> weight &lt;= <span class="number">0</span> {</span><br><span class="line"><span class="keyword">if</span> totalWeight == <span class="number">0</span> {</span><br><span class="line">weight = <span class="number">10</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">weight = totalWeight / <span class="type">int64</span>(n)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">totalWeight += weight</span><br><span class="line">addr := resolver.Address{</span><br><span class="line">Addr:       rpcAddr,</span><br><span class="line">Type:       resolver.Backend,</span><br><span class="line">ServerName: ins.AppID,</span><br><span class="line">Metadata:   &amp;MD{Weight: weight, Color: color},</span><br><span class="line">}</span><br><span class="line">addrs = <span class="built_in">append</span>(addrs, addr)</span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 这一步才是真正调用grpc官方库的方法. 当地址更新后, 需要去更新地址信息以及连接池的连接. </span></span><br><span class="line">r.cc.NewAddress(addrs)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之前的go watch协程中有接收实例信息变化的channel信号, 这个发送这个channel信号是在<code>b.Builder.Build(dsn[0])</code>这个方法中内部进行的. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Discovery)</span></span> Build(appid <span class="type">string</span>) Resolver {</span><br><span class="line">    <span class="comment">// 创建解析注册中心获取到的地址的解析器</span></span><br><span class="line">r := &amp;Resolve{</span><br><span class="line">id:    appid,</span><br><span class="line">d:     d,  <span class="comment">// 当前app的注册发现中心结构体. </span></span><br><span class="line">event: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">1</span>),</span><br><span class="line">}</span><br><span class="line">d.mutex.Lock()</span><br><span class="line">app, ok := d.apps[appid]</span><br><span class="line"><span class="keyword">if</span> !ok {</span><br><span class="line">app = &amp;appInfo{</span><br><span class="line">resolver: <span class="built_in">make</span>(<span class="keyword">map</span>[*Resolve]<span class="keyword">struct</span>{}),</span><br><span class="line">}</span><br><span class="line">d.apps[appid] = app</span><br><span class="line">cancel := d.cancelPolls</span><br><span class="line"><span class="keyword">if</span> cancel != <span class="literal">nil</span> {</span><br><span class="line">cancel()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">app.resolver[r] = <span class="keyword">struct</span>{}{}</span><br><span class="line">d.mutex.Unlock()</span><br><span class="line"><span class="keyword">if</span> ok {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> r.event &lt;- <span class="keyword">struct</span>{}{}:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">log.Infof(<span class="string">"disocvery: AddWatch(%s) already watch(%v)"</span>, appid, ok)</span><br><span class="line">    <span class="comment">// 开启一个协程专门轮巡拉取注册中心关注的所有app服务信息.</span></span><br><span class="line">d.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">go</span> d.serverproc()</span><br><span class="line">})</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Discovery)</span></span> serverproc() {</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">retry  <span class="type">int</span></span><br><span class="line">ctx    context.Context</span><br><span class="line">cancel context.CancelFunc</span><br><span class="line">)</span><br><span class="line">ticker := time.NewTicker(time.Minute * <span class="number">30</span>)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line"><span class="keyword">if</span> ctx == <span class="literal">nil</span> {</span><br><span class="line">ctx, cancel = context.WithCancel(d.ctx)</span><br><span class="line">d.mutex.Lock()</span><br><span class="line">d.cancelPolls = cancel</span><br><span class="line">d.mutex.Unlock()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> &lt;-d.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">}</span><br><span class="line">        <span class="comment">// 轮巡拉取注册中心的所有app, 轮巡时间为30s</span></span><br><span class="line">        <span class="comment">// 这里如果没有变化, 拉取到app信息会是nil. 后续的广播也不会做相应变化</span></span><br><span class="line">apps, err := d.polls(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">d.switchNode()</span><br><span class="line"><span class="keyword">if</span> ctx.Err() == context.Canceled {</span><br><span class="line">ctx = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">retry++</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line">retry = <span class="number">0</span></span><br><span class="line">d.broadcast(apps)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Discovery)</span></span> broadcast(apps <span class="keyword">map</span>[<span class="type">string</span>]*InstancesInfo) {</span><br><span class="line"><span class="keyword">for</span> appID, v := <span class="keyword">range</span> apps {</span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> zone, ins := <span class="keyword">range</span> v.Instances {</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ins) == <span class="number">0</span> {</span><br><span class="line"><span class="built_in">delete</span>(v.Instances, zone)</span><br><span class="line">}</span><br><span class="line">count += <span class="built_in">len</span>(ins)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> {</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">}</span><br><span class="line">d.mutex.RLock()</span><br><span class="line">app, ok := d.apps[appID]</span><br><span class="line">d.mutex.RUnlock()</span><br><span class="line"><span class="keyword">if</span> ok {</span><br><span class="line">app.lastTs = v.LastTs</span><br><span class="line">            <span class="comment">// 保存区域内的所有实例信息</span></span><br><span class="line">app.zoneIns.Store(v)</span><br><span class="line">d.mutex.RLock()</span><br><span class="line">            <span class="comment">// 遍历实例对应的resolvel, 发送更新信号, 表示实例信息更新了. </span></span><br><span class="line"><span class="keyword">for</span> rs := <span class="keyword">range</span> app.resolver {</span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> rs.event &lt;- <span class="keyword">struct</span>{}{}:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">d.mutex.RUnlock()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上是整个discover客户端拉取信息的过程. </p><p>可以看到客户端后续所有的操作都是从grpc调用事先注册的discover Builder的Build方法开始的. </p><p>下面简单的展示一下grpc的拨打方法记录一下grpc是如何连接并管理连接的. </p><p>起点是这个调用方法, 创建conn连接对象, 后面的grpc生成的grpc客户端需要使用到这个连接对象. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">conn, err := grpc.DialContext(ctx, <span class="string">"discovery://default/goim.logic"</span>,</span><br><span class="line">[]grpc.DialOption{</span><br><span class="line">grpc.WithInsecure(),</span><br><span class="line">grpc.WithInitialWindowSize(grpcInitialWindowSize),</span><br><span class="line">grpc.WithInitialConnWindowSize(grpcInitialConnWindowSize),</span><br><span class="line">grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(grpcMaxCallMsgSize)),</span><br><span class="line">grpc.WithDefaultCallOptions(grpc.MaxCallSendMsgSize(grpcMaxSendMsgSize)),</span><br><span class="line">grpc.WithBackoffMaxDelay(grpcBackoffMaxDelay),</span><br><span class="line">grpc.WithKeepaliveParams(keepalive.ClientParameters{</span><br><span class="line">Time:                grpcKeepAliveTime,</span><br><span class="line">Timeout:             grpcKeepAliveTimeout,</span><br><span class="line">PermitWithoutStream: <span class="literal">true</span>,</span><br><span class="line">}),</span><br><span class="line">grpc.WithBalancerName(roundrobin.Name),</span><br><span class="line">}...)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, target <span class="type">string</span>, opts ...DialOption)</span></span> (conn *ClientConn, err <span class="type">error</span>) {</span><br><span class="line">    <span class="comment">// 后面几乎都是操作这个连接对象. </span></span><br><span class="line">cc := &amp;ClientConn{</span><br><span class="line">target:            target,  <span class="comment">// "discovery://default/goim.logic"</span></span><br><span class="line">csMgr:             &amp;connectivityStateManager{},</span><br><span class="line">conns:             <span class="built_in">make</span>(<span class="keyword">map</span>[*addrConn]<span class="keyword">struct</span>{}),</span><br><span class="line">dopts:             defaultDialOptions(),</span><br><span class="line">blockingpicker:    newPickerWrapper(),</span><br><span class="line">czData:            <span class="built_in">new</span>(channelzData),</span><br><span class="line">firstResolveEvent: grpcsync.NewEvent(),</span><br><span class="line">}</span><br><span class="line">cc.retryThrottler.Store((*retryThrottler)(<span class="literal">nil</span>))</span><br><span class="line">cc.ctx, cc.cancel = context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts {</span><br><span class="line">opt.apply(&amp;cc.dopts)</span><br><span class="line">}</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里是获取连接地址的解析器, 根据前缀scheme来获取正确的解析器</span></span><br><span class="line">    <span class="keyword">if</span> cc.dopts.resolverBuilder == <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// Only try to parse target when resolver builder is not already set.</span></span><br><span class="line">cc.parsedTarget = parseTarget(cc.target)</span><br><span class="line">grpclog.Infof(<span class="string">"parsed scheme: %q"</span>, cc.parsedTarget.Scheme)</span><br><span class="line">         <span class="comment">// 比如当前app开始注册了scheme为discover的解析器, 下面就会获取到对应的解析器, 并调用Build方法, 那么所有的起点都是从这个Build方法开始的. </span></span><br><span class="line">cc.dopts.resolverBuilder = resolver.Get(cc.parsedTarget.Scheme)</span><br><span class="line"><span class="keyword">if</span> cc.dopts.resolverBuilder == <span class="literal">nil</span> {</span><br><span class="line"><span class="comment">// If resolver builder is still nil, the parsed target's scheme is</span></span><br><span class="line"><span class="comment">// not registered. Fallback to default resolver and set Endpoint to</span></span><br><span class="line"><span class="comment">// the original target.</span></span><br><span class="line">grpclog.Infof(<span class="string">"scheme %q not registered, fallback to default scheme"</span>, cc.parsedTarget.Scheme)</span><br><span class="line">cc.parsedTarget = resolver.Target{</span><br><span class="line">Scheme:   resolver.GetDefaultScheme(),</span><br><span class="line">Endpoint: target,</span><br><span class="line">}</span><br><span class="line">cc.dopts.resolverBuilder = resolver.Get(cc.parsedTarget.Scheme)</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">cc.parsedTarget = resolver.Target{Endpoint: target}</span><br><span class="line">}</span><br><span class="line">    <span class="comment">// 负载均衡获取对应的地址池</span></span><br><span class="line">    cc.balancerBuildOpts = balancer.BuildOptions{</span><br><span class="line">DialCreds:        credsClone,</span><br><span class="line">CredsBundle:      cc.dopts.copts.CredsBundle,</span><br><span class="line">Dialer:           cc.dopts.copts.Dialer,</span><br><span class="line">ChannelzParentID: cc.channelzID,</span><br><span class="line">Target:           cc.parsedTarget,</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Build the resolver.  下面是真正创建解析器, 并且后面连接解析都是从这里开始的. </span></span><br><span class="line">rWrapper, err := newCCResolverWrapper(cc)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCCResolverWrapper</span><span class="params">(cc *ClientConn)</span></span> (*ccResolverWrapper, <span class="type">error</span>) {</span><br><span class="line">rb := cc.dopts.resolverBuilder</span><br><span class="line"><span class="keyword">if</span> rb == <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"could not get resolver for scheme: %q"</span>, cc.parsedTarget.Scheme)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ccr := &amp;ccResolverWrapper{</span><br><span class="line">cc:     cc,</span><br><span class="line">addrCh: <span class="built_in">make</span>(<span class="keyword">chan</span> []resolver.Address, <span class="number">1</span>),</span><br><span class="line">scCh:   <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="comment">// 调用解析器.  这里会调用discover注册中心实现的Build方法, 然后开始拉取地址, 解析, 最后到调用newAddress来更新地址. 后续负载均衡中心会根据相关策略来获取这些地址. 创建http2连接. </span></span><br><span class="line">    <span class="comment">// 然后grpc客户端最后使用的也是这些管理着的http2连接池中的某一个连接. </span></span><br><span class="line">ccr.resolver, err = rb.Build(cc.parsedTarget, ccr, resolver.BuildOption{DisableServiceConfig: cc.dopts.disableServiceConfig})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ccr, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;grpc配合bilibili-discover的整个连接过程. &lt;/p&gt;
&lt;p&gt;假设现在已经起了一个服务端到发现中心了. 现在需要在commet app从discover中获取到ip信息, 并正确的连接. &lt;/p&gt;
&lt;h4 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="grpc" scheme="http://example.com/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>gprc安装与生成代码</title>
    <link href="http://example.com/2021/09/14/grpc/kro/"/>
    <id>http://example.com/2021/09/14/grpc/kro/</id>
    <published>2021-09-13T16:00:00.000Z</published>
    <updated>2022-09-13T06:04:36.450Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h3><ol><li>安装protoc插件出现问题, 直接按照官网的安装方式来进行安装. 最好自己选择下载压缩包进行安装.</li></ol><p>安装地址:  <a href="https://grpc.io/docs/protoc-installation/#install-pre-compiled-binaries-any-os">https://grpc.io/docs/protoc-installation/#install-pre-compiled-binaries-any-os</a></p><ol start="2"><li><p>goland插件语法提示错误: </p><p>只需要在 <code>File–&gt; Setting–&gt; Protocol Buffers</code>进行设置, 选择自己的第三方的proto文件即可.</p></li></ol><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>当有依赖的时候生成代码需要像下面这么写</p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protoc --go-grpc_out=. helloworld.proto --proto_path=. --proto_path=../../third_party</span><br><span class="line">protoc --go_out=. helloworld.proto --proto_path=. --proto_path=../../third_party</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protoc --proto_path=.  --go_out=paths=source_relative:.   --go-grpc_out=paths=source_relative:. .</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;安装问题&quot;&gt;&lt;a href=&quot;#安装问题&quot; class=&quot;headerlink&quot; title=&quot;安装问题&quot;&gt;&lt;/a&gt;安装问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装protoc插件出现问题, 直接按照官网的安装方式来进行安装. 最好自己选择下载压缩包进行安装.&lt;/li&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="grpc" scheme="http://example.com/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>maven换源</title>
    <link href="http://example.com/2021/07/11/java/maven%E6%8D%A2%E6%BA%90/"/>
    <id>http://example.com/2021/07/11/java/maven%E6%8D%A2%E6%BA%90/</id>
    <published>2021-07-10T16:00:00.000Z</published>
    <updated>2022-09-13T06:01:05.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><h3 id="更换阿里源"><a href="#更换阿里源" class="headerlink" title="更换阿里源"></a>更换阿里源</h3><p><code>vim ~/.m2/settings.xml</code></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>MavenCentral<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmavenApache<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/repository/apache-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span>             </span><br><span class="line">     <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;maven&quot;&gt;&lt;a href=&quot;#maven&quot; class=&quot;headerlink&quot; title=&quot;maven&quot;&gt;&lt;/a&gt;maven&lt;/h2&gt;&lt;h3 id=&quot;更换阿里源&quot;&gt;&lt;a href=&quot;#更换阿里源&quot; class=&quot;headerlink&quot; title=&quot;更换阿</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="java" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
    <category term="maven" scheme="http://example.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Go反射总结</title>
    <link href="http://example.com/2021/05/11/go/basic-go-reflect/"/>
    <id>http://example.com/2021/05/11/go/basic-go-reflect/</id>
    <published>2021-05-10T16:00:00.000Z</published>
    <updated>2022-09-13T06:04:36.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go反射总结"><a href="#Go反射总结" class="headerlink" title="Go反射总结"></a>Go反射总结</h2><p>Go 语言中反射的操作主要定义在标准库 <a href="https://golang.org/pkg/reflect/"><code>reflect</code></a> 中，在标准库中定义了两种类型来表现运行时的对象信息，分别是：<a href="https://golang.org/pkg/reflect/#Value"><code>reflect.Value</code></a>（反射对象的值信息）和 <a href="https://golang.org/pkg/reflect/#Type"><code>reflect.Type</code></a>（反射对象的类型信息），Go 语言中所有反射操作都是基于这两个类型进行的。</p><h3 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h3><p>下面所有反射操作都是基于下面结构体进行的. </p><p>定义了一个User结构体, 并且包含一个方法. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>{</span><br><span class="line">Id <span class="type">int64</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`form:"name" json:"name" binding:"required,gte=5" message:"required:用户名不能为空"`</span></span><br><span class="line">Age <span class="type">uint8</span> <span class="string">`form:"age" json:"age" binding:"required,lt=10" message:"required:年龄不能为空|lt:年龄必须小于10"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> GetName() <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User: "</span> + u.Name</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-Value与Type"><a href="#1-Value与Type" class="headerlink" title="1. Value与Type"></a>1. Value与Type</h3><p>前面说过reflect包提供了2个对象来描述go语言运行时的对象状态信息.  那么首先就需要通过reflect包提供的两个基础方法<code>reflect.ValueOf()</code> 和 <code>reflect.TypeOf()</code>来获取到这两个对象.</p><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">fmt.Println(v)  <span class="comment">// 输出: {1 tom 20}</span></span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">fmt.Println(t)  <span class="comment">// 输出: main.User</span></span><br></pre></td></tr></tbody></table></figure><p>根据基础的打印信息, 可以看出已经知道了u对象的值及其类型信息.  接下来就是需要指导这个对象内更具体的信息. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Type(), t, v.Type() == t) <span class="comment">// main.User main.User true</span></span><br></pre></td></tr></tbody></table></figure><p>type和value可以互相转换</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Type(), t, v.Type() == t) <span class="comment">// main.User main.User true</span></span><br><span class="line">fmt.Println(reflect.New(t))  <span class="comment">// &amp;{0  0}</span></span><br></pre></td></tr></tbody></table></figure><p>通过<code>v.Type()</code>方法可以获取到value对象, 通过<code>relect</code>包的New方法可以获取到Type对象所对应的零值对象. </p><h3 id="2-Kind"><a href="#2-Kind" class="headerlink" title="2. Kind"></a>2. Kind</h3><p><code>Kind</code> 表示反射对象的类型 <code>Type</code> 所代表的具体类型，零值表示无效的类型，下面是<code>reflect</code>包预定义的Kind</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Invalid Kind = <span class="literal">iota</span></span><br><span class="line">Bool</span><br><span class="line">Int</span><br><span class="line">Int8</span><br><span class="line">Int16</span><br><span class="line">Int32</span><br><span class="line">Int64</span><br><span class="line">Uint</span><br><span class="line">Uint8</span><br><span class="line">Uint16</span><br><span class="line">Uint32</span><br><span class="line">Uint64</span><br><span class="line">Uintptr</span><br><span class="line">Float32</span><br><span class="line">Float64</span><br><span class="line">Complex64</span><br><span class="line">Complex128</span><br><span class="line">Array</span><br><span class="line">Chan</span><br><span class="line">Func</span><br><span class="line">Interface</span><br><span class="line">Map</span><br><span class="line">Ptr</span><br><span class="line">Slice</span><br><span class="line">String</span><br><span class="line">Struct</span><br><span class="line">UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>上面的Value和Type对象都有Kind()方法来获取对应的真实类型</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Kind())  <span class="comment">// struct</span></span><br><span class="line">fmt.Println(t.Kind())  <span class="comment">// struct</span></span><br></pre></td></tr></tbody></table></figure><p>通过Type对象和Value对象获取到的Kind可以看到都是<code>struct</code>类型</p><h3 id="3-反射对象的字段"><a href="#3-反射对象的字段" class="headerlink" title="3. 反射对象的字段"></a>3. 反射对象的字段</h3><p><strong>首先需要说明, 这里所说的对象一般都是指代结构体(<code>struct</code>)对象.</strong> </p><p>使用反射一般来说是需要获取到反射的对象的字段信息.  </p><h4 id="NumField"><a href="#NumField" class="headerlink" title="NumField"></a><code>NumField</code></h4><p>Value对象和Type对象都有<code>NumField</code>这个方法来获取到结构体对象的字段数量</p><p>使用这个方法必须要求被反射的原始对象必须为结构体, 即使是一个指向结构体对象的指针也会panic错误. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">fmt.Println(reflect.ValueOf(u).NumField())   <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a><code>Field</code></h4><p>获取到了数量之后, 可以通过for循环来遍历所有字段, 使用Field(i)方法来获取到对应的字段信息. </p><p>Type对象获取到的对应的字段是结构体对象定义的元信息, 如tag信息, 字段名字, 字段类型等…</p><p>Value对象获取到的是对应字段的值</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line"><span class="comment">// fmt.Println(reflect.ValueOf(u).NumField())</span></span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ {</span><br><span class="line">typeField := t.Field(i)</span><br><span class="line">valueField := v.Field(i)</span><br><span class="line">fmt.Println(<span class="string">"typeField"</span>, typeField)</span><br><span class="line">fmt.Println(<span class="string">"valueField"</span>, valueField)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后输出如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typeField {Id  <span class="type">int64</span>  <span class="number">0</span> [<span class="number">0</span>] <span class="literal">false</span>}</span><br><span class="line">valueField <span class="number">1</span></span><br><span class="line">typeField {Name  <span class="type">string</span> form:<span class="string">"name"</span> json:<span class="string">"name"</span> binding:<span class="string">"required,gte=5"</span> message:<span class="string">"required:用户名不能为空"</span> <span class="number">8</span> [<span class="number">1</span>] <span class="literal">false</span>}</span><br><span class="line">valueField tom</span><br><span class="line">typeField {Age  <span class="type">uint8</span> form:<span class="string">"age"</span> json:<span class="string">"age"</span> binding:<span class="string">"required,lt=10"</span> message:<span class="string">"required:年龄不能为空|lt:年龄必须小于10"</span> <span class="number">24</span> [<span class="number">2</span>] <span class="literal">false</span>}</span><br><span class="line">valueField <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到<code>typeField</code>输出了结构体定义时的完整的信息</p><p>这个<code>typefield</code>是<code>StructField</code>类型, 在reflect包中定义如下</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> {</span><br><span class="line"><span class="comment">// Name is the field name.</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line"><span class="comment">// PkgPath is the package path that qualifies a lower case (unexported)</span></span><br><span class="line"><span class="comment">// field name. It is empty for upper case (exported) field names.</span></span><br><span class="line"><span class="comment">// See https://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">PkgPath <span class="type">string</span></span><br><span class="line"></span><br><span class="line">Type      Type      <span class="comment">// field type</span></span><br><span class="line">Tag       StructTag <span class="comment">// field tag string</span></span><br><span class="line">Offset    <span class="type">uintptr</span>   <span class="comment">// offset within struct, in bytes</span></span><br><span class="line">Index     []<span class="type">int</span>     <span class="comment">// index sequence for Type.FieldByIndex</span></span><br><span class="line">Anonymous <span class="type">bool</span>      <span class="comment">// is an embedded field</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>主要关注Tag, Name, Type参数分别是字段的tag, 名字及其类型, 利用这几个参数就尤其是可以通过tag来实现很多自动化的工作了.  如gin框架中的校验器使用的<code>validate </code>tag以及序列化所使用到的<code>json </code>tag都是利用反射获取tag信息来完成的. </p><p>上面的<code>valueField</code>返回的还是一个Value对象, 通过这个Value对象可以获取每个字段的值, 如果字段仍然是<code>struct</code>类型, 那么可以继续递归操作. </p><h3 id="4-Elem"><a href="#4-Elem" class="headerlink" title="4. Elem"></a>4. Elem</h3><p><code>Elem()</code> 方法定义：<code>func (v Value) Elem() Value</code>，返回 <code>v</code> 包含的值或指针 <code>v</code> 指向的值，<code>v</code> 的 <code>Kind</code> 如果不是 <code>Interface</code> 或 <code>Ptr</code>，则会 panic. Elem方法等效于对指针类型变量做了一个<code>*</code>操作, 不过这个也有不同的地方. </p><p>当需要对反射的对象做修改操作时, 就必须用到Elem方法.  举一个demo. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">fmt.Println(<span class="string">"before u: ...."</span>, u)</span><br><span class="line">elem := reflect.ValueOf(&amp;u).Elem()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; elem.NumField(); i++ {</span><br><span class="line">eleField := elem.Field(i)</span><br><span class="line"><span class="keyword">if</span> eleField.CanSet() {</span><br><span class="line"><span class="keyword">if</span> eleField.Kind() == reflect.String {</span><br><span class="line">eleField.SetString(<span class="string">"修改后String"</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> eleField.Kind() == reflect.Int {</span><br><span class="line">eleField.SetInt(<span class="number">333333</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> eleField.Kind() == reflect.Int64 {</span><br><span class="line">eleField.SetInt(<span class="number">6666666</span>)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="string">"after u: ...."</span>, u)</span><br></pre></td></tr></tbody></table></figure><p>输出结果</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before u: .... {<span class="number">1</span> tom <span class="number">20</span>}</span><br><span class="line">after u: .... {<span class="number">6666666</span> 修改后String <span class="number">20</span>}</span><br></pre></td></tr></tbody></table></figure><p>上面使用到了<code>CanSet</code>方法, 这个是只有使用elem方法获取到field才会返回True, 才可以做后面的修改值操作. </p><p>总而言之, elem方法其实就是相当于对获取到的字段做了一次取指针操作, 与直接使用没有太大的区别. </p><h3 id="5-反射对象的方法"><a href="#5-反射对象的方法" class="headerlink" title="5. 反射对象的方法"></a>5. 反射对象的方法</h3><p>获取方法对象和获取属性很类似, 使用方法都在下面的注释说明了.  不过里面需要注意的是方法入参还把接收对象也当做入参参数之一了. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ {</span><br><span class="line">method := t.Method(i)  <span class="comment">// 返回方法结构体</span></span><br><span class="line">vMethod := v.Method(i)</span><br><span class="line">mt := method.Type</span><br><span class="line">fmt.Println(method, vMethod, <span class="string">"====="</span>, method.Type)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取入参参数, 结构体对象的方法, 获取的方法信息对象会把方法的接受者也当着入参之一</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; mt.NumIn(); j++ {</span><br><span class="line">in := mt.In(j)</span><br><span class="line">fmt.Println(<span class="string">"in ......."</span>, in, in.Name(), in.Kind())  <span class="comment">// in ....... main.User User struct</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法返回类型</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; mt.NumOut(); j++ {</span><br><span class="line">fmt.Println(<span class="string">"method out type:"</span>, mt.Out(j))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的调用</span></span><br><span class="line"><span class="keyword">if</span> method.Name == <span class="string">"SetName"</span> {</span><br><span class="line"><span class="comment">// 这里需要组织入参参数, 都是value类型的, 需要注意要传接收对象</span></span><br><span class="line">ins := []reflect.Value{reflect.ValueOf(u), reflect.ValueOf(<span class="string">"反射调用方法值"</span>)}</span><br><span class="line">method.Func.Call(ins)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-其他方法"><a href="#6-其他方法" class="headerlink" title="6. 其他方法"></a>6. 其他方法</h3><p><code>FieldByName</code> 直接通过名字获取到对应的字段信息</p><p><code>MethodByName</code> 直接通过方法名字获取到对应的方法结构体</p><p>上面两种方式获取到结构体对象与遍历Field(index)的效果是一样的. 具体使用哪种看需求. </p><p><code>Interface</code> 是value对象的方法. 通过这个interface可还原取到value对象的原始值</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">u := User{<span class="number">1</span>, <span class="string">"tom"</span>, <span class="number">20</span>}</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line"><span class="keyword">if</span> name, exist := t.FieldByName(<span class="string">"Name"</span>); exist {</span><br><span class="line">fmt.Println(name.Name, name.Tag)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> fun, exist := t.MethodByName(<span class="string">"SetName"</span>); exist {</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">ins := []reflect.Value{reflect.ValueOf(u), reflect.ValueOf(<span class="string">"反射调用方法值"</span>)}</span><br><span class="line">fun.Func.Call(ins)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用Interface方法还原对象</span></span><br><span class="line"><span class="keyword">if</span> u1, ok := v.Interface().(User); ok {</span><br><span class="line">fmt.Println(<span class="string">"after:"</span>, u1.Name, u1.Age)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h3><ul><li><a href="https://ehlxr.me/2018/01/26/golang-reflect/">Golang 反射使用总结</a></li><li><a href="https://golang.org/pkg/reflect/#Type">官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go反射总结&quot;&gt;&lt;a href=&quot;#Go反射总结&quot; class=&quot;headerlink&quot; title=&quot;Go反射总结&quot;&gt;&lt;/a&gt;Go反射总结&lt;/h2&gt;&lt;p&gt;Go 语言中反射的操作主要定义在标准库 &lt;a href=&quot;https://golang.org/pkg/re</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="go基础" scheme="http://example.com/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>基于go-zero框架搭建短链服务Demo</title>
    <link href="http://example.com/2021/04/30/go/2-shortcut/"/>
    <id>http://example.com/2021/04/30/go/2-shortcut/</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2022-09-13T06:04:36.454Z</updated>
    
    <content type="html"><![CDATA[<p>根据go-zero官方的demo示例, 尝试搭建一个shorturl短链服务.</p><h2 id="搭建短链服务"><a href="#搭建短链服务" class="headerlink" title="搭建短链服务"></a>搭建短链服务</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>整个服务叫做短链服务, 项目名称就叫做shorturl, 然后需要在里面创建两个文件夹<code>api</code>和<code>rpc</code>. </p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module shorturl</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.15</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/antlr/antlr4 v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210412152734</span>-e404d26f6142 <span class="comment">// indirect</span></span><br><span class="line">github.com/<span class="keyword">go</span>-sql-driver/mysql v1<span class="number">.6</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/golang/protobuf v1<span class="number">.4</span><span class="number">.2</span></span><br><span class="line">github.com/iancoleman/strcase v0<span class="number">.1</span><span class="number">.3</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/tal-tech/<span class="keyword">go</span>-zero v1<span class="number">.1</span><span class="number">.6</span></span><br><span class="line"><span class="keyword">go</span>.uber.org/automaxprocs v1<span class="number">.4</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">google.golang.org/grpc v1<span class="number">.29</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h3 id="编写api服务"><a href="#编写api服务" class="headerlink" title="编写api服务"></a>编写api服务</h3><p>既然是做微服务demo, 那么最重要的就是编写api网关相关的代码了, 这相当于微服务的大脑. 根据官方文档, 首先需要使用goctl工具创建api的模板代码.  </p><h4 id="编写api文件"><a href="#编写api文件" class="headerlink" title="编写api文件"></a>编写api文件</h4><p>进入到api文件夹下,  使用<code>goctl api -o shorturl.api</code>命令, 会在当前目录下创建出一个<code>shorturl.api</code>的模板文件, 接下来需要对这个文件进行编辑. </p><p>先不用管文件内的info相关信息, 直接去除. 然后就可以像go的编码习惯一样, 先定义变量(传输用的结构体) , 然后编写接口函数(这里叫做定义服务). </p><blockquote><p>因为是短链服务,  两个基础功能是必须的, 一个是根据原始url返回缩短后的url,  一个是根据缩短后的url去查原始url. 由这两个功能, 需要定义的数据传输的结构体就容易了. </p></blockquote><p>整体代码如下所示</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"v1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义根据短链查原始链接的请求与响应的相关结构体</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">expandReq {</span><br><span class="line">shorten <span class="type">string</span> <span class="string">`form:shorten`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">expandResp {</span><br><span class="line">url <span class="type">string</span> <span class="string">`json:url`</span></span><br><span class="line">}</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义根据长链缩短原始链接的相关结构体</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">shortenReq {</span><br><span class="line">url <span class="type">string</span> <span class="string">`from:url`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">shortenResp {</span><br><span class="line">shorten <span class="type">string</span> <span class="string">`json:shorten`</span></span><br><span class="line">}</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个shorturl的服务, 名字叫做shorturl-api</span></span><br><span class="line"><span class="comment">// 主要定义两个接口功能, 一个用来缩短原始长链, 一个用来根据短链来查原始链接</span></span><br><span class="line">service shorturl-api {</span><br><span class="line"><span class="comment">// 定义server需要用到的相关属性</span></span><br><span class="line">@server (</span><br><span class="line">handler: shortenHandler</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义url, 参数就是上面定义到的结构体, 返回信息也在上面进行了定义</span></span><br><span class="line">get /shorten(shortenReq) returns(shortenResp)</span><br><span class="line"></span><br><span class="line">@server (</span><br><span class="line">handler: expandHandler</span><br><span class="line">)</span><br><span class="line">get /expand(expandReq) returns(expandResp)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单对上面的代码进行说明</p><ul><li>type和go一样进行结构体的声明</li><li>service shorturl-api表示定义一个叫shorturl-api的服务, 里面会定义这个服务相关的http请求方法</li><li>@server部分用来定义 server 端用到的属性</li></ul><ul><li><code>handler</code> 定义了服务端 handler 名字</li><li><code>get /shorten(shortenReq) returns(shortenResp)</code> 定义了 get 方法的路由、请求参数、返回参数等</li></ul><h4 id="生成api网关代码"><a href="#生成api网关代码" class="headerlink" title="生成api网关代码"></a>生成api网关代码</h4><p>使用goctl工具生成api gateway代码, 同样在api目录下使用<code> goctl api go -api shorturl.api -dir .</code>命令生成api网关相关的代码. </p><p>大致目录如下所示</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   ├── etc</span><br><span class="line">│   │   └── shorturl-api.yaml         // 配置文件</span><br><span class="line">│   ├── internal</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   │   └── config.go             // 定义配置</span><br><span class="line">│   │   ├── handler</span><br><span class="line">│   │   │   ├── expandhandler.go      // 实现 expandHandler</span><br><span class="line">│   │   │   ├── routes.go             // 定义路由处理</span><br><span class="line">│   │   │   └── shortenhandler.go     // 实现 shortenHandler</span><br><span class="line">│   │   ├── logic</span><br><span class="line">│   │   │   ├── expandlogic.go        // 实现 ExpandLogic</span><br><span class="line">│   │   │   └── shortenlogic.go       // 实现 ShortenLogic</span><br><span class="line">│   │   ├── svc</span><br><span class="line">│   │   │   └── servicecontext.go     // 定义 ServiceContext</span><br><span class="line">│   │   └── types</span><br><span class="line">│   │       └── types.go              // 定义请求、返回结构体</span><br><span class="line">│   ├── shorturl.api</span><br><span class="line">│   └── shorturl.go                   // main 入口定义</span><br></pre></td></tr></tbody></table></figure><p>到这其实就已经可以启动api网关了, 默认的监听端口为8888</p><p><code>go run shorturl.go -f etc/shorturl-api.yaml</code></p><p>终端会打印出<code>Starting server at 0.0.0.0:8888...</code>的log消息, 说明到目前为止, 环境配的没啥问题. </p><p>由于在shorturl.api文件中已经定义好了两个路由, 所以可以直接去请求api网关接口测试</p><p><strong>发起请求测试</strong></p><p><code>curl -i "http://localhost:8888/shorten?url=http://www.xiaoheiban.cn"</code></p><p>返回信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Thu, 29 Apr 2021 08:20:51 GMT</span><br><span class="line">Content-Length: 14</span><br><span class="line"></span><br><span class="line">{"shorten":""}</span><br></pre></td></tr></tbody></table></figure><p>因为当前没有对生成的代码做任何的逻辑处理, 所以就直接返回shorturl.api文件中定义的shortenResp的默认值. </p><p>如果需要修改返回逻辑可以直接像下面这么操作</p><ul><li>可以修改 <code>internal/svc/servicecontext.go</code> 来传递服务依赖（如果需要）</li><li>实现逻辑可以修改 <code>internal/logic</code> 下的对应文件</li></ul><p>但是直接修改里面的返回逻辑的话, 就又变成单体应用了, 就不符合这是个微服务框架demo的初衷. 所以接下来需要编写rpc程序来实现相关的业务逻辑代码. </p><h3 id="编写-transform-rpc-服务"><a href="#编写-transform-rpc-服务" class="headerlink" title="编写 transform rpc 服务"></a>编写 transform rpc 服务</h3><h4 id="编写-transform-proto-文件"><a href="#编写-transform-proto-文件" class="headerlink" title="编写 transform.proto 文件"></a>编写 <code>transform.proto</code> 文件</h4><p>由于服务之间通信是使用grpc,  因而需要按照grpc的逻辑来编写rpc的逻辑.  </p><p>grpc的基础思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 作为接口定义语言，来描述服务接口和有效载荷消息结构。</p><p>Protobuf的语法教程可以参考这篇博客 [ <a href="">Protobuf 终极教程</a>] 和<a href="https://developers.google.com/protocol-buffers/docs/overview#services">官方教程</a></p><p>首先在rpc目录下<strong>创建transform目录</strong>, 代表这个一个Transform服务, 进入到对应目录, 然后需要编写proto文件,  这个可以通过goctl工具生成一个模板文件. </p><figure class="highlight protobuf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> transform;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">expandReq</span> {</span><br><span class="line">  <span class="type">string</span> shorten = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">expandResp</span> {</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">shortenReq</span> {</span><br><span class="line">  <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">shortenResp</span> {</span><br><span class="line">  <span class="type">string</span> shorten = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义rpc传输的格式</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">transform</span> {</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> shorten(shortenReq) <span class="keyword">returns</span>(shortenResp)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> expand(expandReq) <span class="keyword">returns</span>(expandResp)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="生成rpc代码"><a href="#生成rpc代码" class="headerlink" title="生成rpc代码"></a>生成rpc代码</h4><p>定义好了服务之间通信的数据格式和相应服务, 接下来就可以用goctl工具生成相应rpc代码. 这一命令依赖于protoc生成代码工具, 需要事先在环境准备中准备完整. </p><p><code>goctl rpc proto -src transform.proto -dir .</code> 执行完成之后, 会生成如下的文件结构:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rpc/transform</span><br><span class="line">├── etc</span><br><span class="line">│   └── transform.yaml              // 配置文件</span><br><span class="line">├── internal</span><br><span class="line">│   ├── config</span><br><span class="line">│   │   └── config.go               // 配置定义</span><br><span class="line">│   ├── logic</span><br><span class="line">│   │   ├── expandlogic.go          // expand 业务逻辑在这里实现</span><br><span class="line">│   │   └── shortenlogic.go         // shorten 业务逻辑在这里实现</span><br><span class="line">│   ├── server</span><br><span class="line">│   │   └── transformerserver.go    // 调用入口, 不需要修改</span><br><span class="line">│   └── svc</span><br><span class="line">│       └── servicecontext.go       // 定义 ServiceContext，传递依赖</span><br><span class="line">├── transform</span><br><span class="line">│   └── transform.pb.go</span><br><span class="line">├── transform.go                    // rpc 服务 main 函数</span><br><span class="line">├── transform.proto</span><br><span class="line">└── transformer</span><br><span class="line">    ├── transformer.go              // 提供了外部调用方法，无需修改</span><br><span class="line">    ├── transformer_mock.go         // mock 方法，测试用</span><br><span class="line">    └── types.go                    // request/response 结构体定义</span><br></pre></td></tr></tbody></table></figure><p>文件生成之后, 接下来可以直接运行代码. </p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run transform.<span class="keyword">go</span> -f etc/transform.yaml</span><br></pre></td></tr></tbody></table></figure><p>运行之前, 需要检查一下etcd是否有正常运行, 因为微服务之间的注册发现依赖于etcd来进行管理. </p><h3 id="api网关调用rpc服务"><a href="#api网关调用rpc服务" class="headerlink" title="api网关调用rpc服务"></a>api网关调用rpc服务</h3><p>修改api/etc目录下的配置文件 <code>shorturl-api.yaml</code>，增加如下内容</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Transform:</span></span><br><span class="line">  <span class="attr">Etcd:</span></span><br><span class="line">    <span class="attr">Hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">localhost:2379</span></span><br><span class="line">    <span class="attr">Key:</span> <span class="string">transform.rpc</span></span><br></pre></td></tr></tbody></table></figure><p>通过 etcd 自动去发现可用的 transform 服务.</p><p>接下来需要修改config配置, 添加rpc的依赖选项, 具体是修改 <code>internal/config/config.go</code> 如下，增加 transform 服务依赖.</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">rest.RestConf</span><br><span class="line">Transform zrpc.RpcClientConf</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个config里面添加依赖之后, 简单阅读生成的代码段, 知道这个config会包装成context, 传进与路由匹配的Handler中. 这样我们的业务逻辑就可以利用到这个依赖了, 也就是可以通过rpc调用其他服务的代码了.  这里只是简单的提一下, 后面再来看这里的源码到底是如何实现的. </p><p>修改 <code>internal/svc/servicecontext.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是对原始的config做了一层包装.</span></span><br><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> {</span><br><span class="line">Config config.Config</span><br><span class="line">Transformer transformer.Transformer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceContext</span><span class="params">(c config.Config)</span></span> *ServiceContext {</span><br><span class="line"><span class="keyword">return</span> &amp;ServiceContext{</span><br><span class="line">Config: c,</span><br><span class="line"><span class="comment">// 下面添加Transformer</span></span><br><span class="line">Transformer: transformer.NewTransformer(zrpc.MustNewClient(c.Transform)),</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最终不同的业务逻辑之间就是通过这个ServiceContext对象来传递依赖的. </p><p>接下来需要扩充api网关的逻辑. 在expand方法里面补充调用远程rpc接口代码</p><p>修改 <code>internal/logic/expandlogic.go</code> 里的 <code>Expand</code> 方法，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ExpandLogic)</span></span> Expand(req types.ExpandReq) (*types.ExpandResp, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// 在这里是真正实现自己的业务逻辑, 这里调用rpc服务</span></span><br><span class="line">resp, err := l.svcCtx.Transformer.Expand(l.ctx, &amp;transformer.ExpandReq{</span><br><span class="line">Shorten: req.Shorten,</span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> &amp;types.ExpandResp{}, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;types.ExpandResp{Url: resp.Url}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同理需要补充生成短链的调用rpc的代码逻辑. 修改 <code>internal/logic/shortenlogic.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ShortenLogic)</span></span> Shorten(req types.ShortenReq) (*types.ShortenResp, <span class="type">error</span>) {</span><br><span class="line">resp, err := l.svcCtx.Transformer.Shorten(l.ctx, &amp;transformer.ShortenReq{</span><br><span class="line">Url: req.Url,</span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> &amp;types.ShortenResp{}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;types.ShortenResp{Shorten: resp.Shorten}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此, api网关调用rpc的逻辑代码都已书写完毕, 但是rpc之前只是自动生成了代码, 真正的服务代码逻辑还没有实现, 需要接下来去完成. </p><h3 id="数据库与model"><a href="#数据库与model" class="headerlink" title="数据库与model"></a>数据库与model</h3><p>由于短链服务的实现代码是在rpc中完成的, 接下来需要完善一系列逻辑.</p><p>首先是需要用到的mysql和redis数据库. </p><h4 id="定义数据库表"><a href="#定义数据库表" class="headerlink" title="定义数据库表"></a>定义数据库表</h4><p>进入到rpc/transform目录下, 创建model文件夹, 创建<code>shorturl.sql</code>文件</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `shorturl` (</span><br><span class="line">  `shorten` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'shorten key'</span>,</span><br><span class="line">  `url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'original url'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`shorten`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><p>短链服务说简单点就是一个原始长链和生成的短链需要建立一个映射关系, 然后一般需要拿到那个短链来到数据库查原始长链, 然后302重定向原始链接的过程. 所以上面的数据库就设计的比较简单, 只有两个关键字段</p><p>登录到数据库, 创建数据库, 执行刚刚的sql文件. </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database gozero;</span><br><span class="line">use gozero;</span><br><span class="line">source shorturl.sql</span><br></pre></td></tr></tbody></table></figure><p>在model目录下执行命令<code> goctl model mysql ddl -c -src shorturl.sql -dir .</code>可以生成带curd+cache的模板代码.  -c<code>表示使用</code>redis cache</p><p>最后生成的文件结构为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpc/transform/model</span><br><span class="line">├── shorturl.sql</span><br><span class="line">├── shorturlmodel.go              // CRUD+cache 代码</span><br><span class="line">└── vars.go                       // 定义常量和变量</span><br></pre></td></tr></tbody></table></figure><h3 id="修改rpc服务"><a href="#修改rpc服务" class="headerlink" title="修改rpc服务"></a>修改rpc服务</h3><h4 id="修改数据库参数"><a href="#修改数据库参数" class="headerlink" title="修改数据库参数"></a>修改数据库参数</h4><p>涉及到数据库的操作, 需要配置数据库连接参数. </p><p>修改 <code>rpc/transform/etc/transform.yaml</code>，增加如下内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DataSource:</span> <span class="string">root:root@tcp(localhost:3306)/gozero</span></span><br><span class="line"><span class="attr">Table:</span> <span class="string">shorturl</span></span><br><span class="line"><span class="attr">Cache:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Host:</span> <span class="string">localhost:6379</span></span><br></pre></td></tr></tbody></table></figure><p>可以使用多个 redis 作为 cache，支持 redis 单点或者 redis 集群. </p><h4 id="修改依赖文件"><a href="#修改依赖文件" class="headerlink" title="修改依赖文件"></a>修改依赖文件</h4><p>修改<code>rpc/transform/internal/config/config.go</code>文件, 添加数据库相关的依赖</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">zrpc.RpcServerConf</span><br><span class="line"><span class="comment">// 暂时还不知道下面几个配置的具体左右, 需要查看源码来查看. </span></span><br><span class="line">DataSource <span class="type">string</span></span><br><span class="line">Table <span class="type">string</span></span><br><span class="line">Cache cache.CacheConf</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>增加mysql和redis依赖</p><p>修改 <code>rpc/transform/internal/svc/servicecontext.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceContext <span class="keyword">struct</span> {</span><br><span class="line">Config config.Config</span><br><span class="line">Model model.ShorturlModel</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServiceContext</span><span class="params">(c config.Config)</span></span> *ServiceContext {</span><br><span class="line"><span class="keyword">return</span> &amp;ServiceContext{</span><br><span class="line">Config: c,</span><br><span class="line">Model: model.NewShorturlModel(sqlx.NewMysql(c.DataSource), c.Cache),</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来需要编写生成短链和还原短链的逻辑代码了. </p><p>修改 <code>rpc/transform/internal/logic/expandlogic.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ExpandLogic)</span></span> Expand(in *transform.ExpandReq) (*transform.ExpandResp, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// 根据短链查库还原长链</span></span><br><span class="line">shorturl, err := l.svcCtx.Model.FindOne(in.Shorten)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;transform.ExpandResp{Url: shorturl.Url}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改 <code>rpc/transform/internal/logic/shortenlogic.go</code>，如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ShortenLogic)</span></span> Shorten(in *transform.ShortenReq) (*transform.ShortenResp, <span class="type">error</span>) {</span><br><span class="line"><span class="comment">// 简单的实现短链的方法, 只是粗略的实现相关的逻辑. 不考虑重复碰撞的问题.</span></span><br><span class="line">key := hash.Md5Hex([]<span class="type">byte</span>(in.Url))[:<span class="number">6</span>]</span><br><span class="line">_, err := l.svcCtx.Model.Insert(model.Shorturl{</span><br><span class="line">Url:     in.Url,</span><br><span class="line">Shorten: key,</span><br><span class="line">})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;transform.ShortenResp{</span><br><span class="line">Shorten: key,</span><br><span class="line">}, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="完整调用测试"><a href="#完整调用测试" class="headerlink" title="完整调用测试"></a>完整调用测试</h3><p>这里面有一个小疑问(必须先启动rpc服务, 然后api网关才能正常启动). </p><p>在终端输入: <code> curl -i "http://localhost:8888/shorten?url=http://www.google.com"</code></p><p>返回信息</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Fri, 30 Apr 2021 02:36:22 GMT</span><br><span class="line">Content-Length: 20</span><br><span class="line"></span><br><span class="line">{"shorten":"ed646a"}</span><br></pre></td></tr></tbody></table></figure><p>拿到刚才获取到的短链, 然后去获取原始长链</p><p><code>curl -i "http://localhost:8888/expand?shorten=ed646a"</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Fri, 30 Apr 2021 02:36:53 GMT</span><br><span class="line">Content-Length: 31</span><br><span class="line"></span><br><span class="line">{"url":"http://www.google.com"}</span><br></pre></td></tr></tbody></table></figure><p>可以看到正确的返回了原始的长链, 说明demo服务已经完全跑通了. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据go-zero官方的demo示例, 尝试搭建一个shorturl短链服务.&lt;/p&gt;
&lt;h2 id=&quot;搭建短链服务&quot;&gt;&lt;a href=&quot;#搭建短链服务&quot; class=&quot;headerlink&quot; title=&quot;搭建短链服务&quot;&gt;&lt;/a&gt;搭建短链服务&lt;/h2&gt;&lt;h3 id=&quot;环境</summary>
      
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="go" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/go/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="go-zero" scheme="http://example.com/tags/go-zero/"/>
    
  </entry>
  
  <entry>
    <title>基于frp进行内网穿透</title>
    <link href="http://example.com/2021/04/28/linux/frp-network/"/>
    <id>http://example.com/2021/04/28/linux/frp-network/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于frp进行内网穿透"><a href="#基于frp进行内网穿透" class="headerlink" title="基于frp进行内网穿透"></a>基于<code>frp</code>进行内网穿透</h2><p>公司的数据库环境,服务器环境都是内网环境,  如果想要在家里想要办公, 就需要从公网中访问自己的私有设备(在公司里的电脑),  这不是那么容易.  但是自己搭建<code>frp</code>服务器进行内网穿透，可以达到不错的速度，且理论上可以开放任何想要的端口，可以实现的功能远不止远程桌面或者文件共享, 这也是<code>frp</code>这款开源软件的优势.</p><h3 id="frp了解"><a href="#frp了解" class="headerlink" title="frp了解"></a><code>frp</code>了解</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>frp </code>是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>frp 主要由 <strong>客户端(frpc)</strong> 和 <strong>服务端(frps)</strong> 组成，服务端通常部署在具有公网 IP 的机器上，客户端通常部署在需要穿透的内网服务所在的机器上。</p><p>内网服务由于没有公网 IP，不能被非局域网内的其他用户访问。</p><p>用户通过访问服务端的 frps，由 frp 负责根据请求的端口或其他信息将请求路由到对应的内网机器，从而实现通信。</p><h3 id="frp搭建"><a href="#frp搭建" class="headerlink" title="frp搭建"></a><code>frp</code>搭建</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li><p>一台需要准备公网上的服务器</p></li><li><p>一台处于内网中的可以连接网络的待访问目标设备.</p></li></ul><h4 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h4><p>由于<code>frp</code>是使用go进行开发的, 所以安装及其方便. </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取源码文件, 这是目前为止的最新版</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar -zxvf frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改名</span></span><br><span class="line">mv frp_0.36.2_linux_amd64 frp</span><br><span class="line"></span><br><span class="line">cd frp</span><br></pre></td></tr></tbody></table></figure><p><code>frp</code>服务端主要有两个文件以s结尾(server)的文件需要关注.</p><p><code>frps </code>和<code>frps.ini </code></p><p><code>frps</code>是可执行文件, 后者是配置文件</p><p>参考配置可以是如下</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 端口配置为12139</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">12139</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = xxxxx</span><br><span class="line"><span class="comment"># vhost_http_port = 10080</span></span><br><span class="line"><span class="comment"># vhost_https_port = 10443</span></span><br></pre></td></tr></tbody></table></figure><ul><li>“bind_port”表示用于客户端和服务端连接的端口，这个端口号我们之后在配置客户端的时候要用到。</li><li>“dashboard_port”是服务端仪表板的端口，若使用7500端口，在配置完成服务启动后可以通过浏览器访问 x.x.x.x:7500 （其中x.x.x.x为服务器的IP）查看frp服务运行信息。</li><li>“token”是用于客户端和服务端连接的口令，相当于秘钥。</li><li>“dashboard_user”和“dashboard_pwd”表示打开仪表板页面登录的用户名和密码。</li><li>“vhost_http_port”和“vhost_https_port”用于反向代理HTTP主机时使用。</li></ul><h4 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></tbody></table></figure><p>上面启动后, 会在当前终端运行, 还需要配置成在<strong>后台运行</strong>, 使用Linux的<code>nohup</code>命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></tbody></table></figure><h4 id="客户端安装与配置"><a href="#客户端安装与配置" class="headerlink" title="客户端安装与配置"></a>客户端安装与配置</h4><p>客户端安装方式如出一辙, 在<code>github</code>上下载对应系统的文件即可. 这里以windows为例.</p><p>下载地址:  <a href="https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_windows_amd64.zip">frp_0.36.2_windows_amd64.zip</a></p><p>下载完解压后和服务端一样, 解压后只需要关注两个c结尾(client)的文件</p><p><code>frpc.ini </code>和 <code>frpc</code></p><p>编辑frpc.ini文件</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">12139</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"><span class="section">[remote]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span>           </span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span></span><br><span class="line"><span class="attr">remote_port</span> =<span class="number">13389</span>  </span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></tbody></table></figure><p>server_addr就是服务端的的地址 token是之前服务端配置的token. </p><p>下面可以配置多个需要代理, 可以是windows的远程端口和ssh的22端口.   local_port表示本地的服务的端口, remote_port表示远程访问的端口(后面如果需要访问当前配置的机器, 需要访问这个remote_port端口). </p><p>配置完启动即可. </p><h4 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c frpc.ini</span><br></pre></td></tr></tbody></table></figure><p>客户端也需要后台运行和开机自启, 尤其是windows电脑, 每次重启都需要配置启动, 很麻烦. </p><p>windows开机自启教程可以参考这篇文章 <a href="https://lo-li.cn/239">frp教程</a></p><h4 id="安全访问"><a href="#安全访问" class="headerlink" title="安全访问"></a>安全访问</h4><p>官方文档还提到了安全的问题,  按照上面的方式配置完之后, 相当于把内网的机器(公司的机器)暴露在互联网之中了,  那么需要考虑更安全的方式. 参考官方文档<a href="https://gofrp.org/docs/examples/stcp/">安全地暴露内网服务</a></p><p>可以使用 <code>stcp(secret tcp)</code> 类型的代理可以避免让任何人都能访问到要穿透的服务，但是我们访问也需要运行另外一个 frpc 客户端。</p><h4 id="安全访问配置"><a href="#安全访问配置" class="headerlink" title="安全访问配置"></a>安全访问配置</h4><p>服务端配置不需要进行配置, 但是客户端就需要进行改变了. </p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">12139</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="section">[secret_ssh]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="comment"># 只有 sk 一致的用户才能访问到此服务</span></span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="section">[remote]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span>           </span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span></span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br></pre></td></tr></tbody></table></figure><p>多个一个配置秘钥sk, 但是不在需要remote_port了. 因为我们访问者也需要启动frp客户端, 因此直接与frp服务器进行通信即可.  下面是访问者的客户端配置</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">12139</span></span><br><span class="line"></span><br><span class="line"><span class="section">[secret_ssh_visitor]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="comment"># stcp 的访问者</span></span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="comment"># 要访问的 stcp 代理的名字</span></span><br><span class="line"><span class="attr">server_name</span> = secret_ssh</span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="comment"># 绑定本地端口用于访问 SSH 服务</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[remote_visitor]</span></span><br><span class="line"><span class="attr">type</span> = stcp</span><br><span class="line"><span class="comment"># stcp 的访问者</span></span><br><span class="line"><span class="attr">role</span> = visitor</span><br><span class="line"><span class="comment"># 要访问的 stcp 代理的名字</span></span><br><span class="line"><span class="attr">server_name</span> = remote</span><br><span class="line"><span class="attr">sk</span> = abcdefg</span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">8999</span></span><br></pre></td></tr></tbody></table></figure><p>经过这样配置之后, 启动本地的客户端后, 接下来就可以访问到内网的机器了. </p><h3 id="访问内网机器"><a href="#访问内网机器" class="headerlink" title="访问内网机器"></a>访问内网机器</h3><p>可以通过远程访问工具直接控制内网机器, 或者通过ssh隧道方式来进行访问. </p><p>我们现在需要访问内网上的网站, 可以利用ssh开启一个socks5代理, 然后让浏览器转发到代理上, 但这个需要借助一个<code>SwitchyOmiga</code>的谷歌代理插件. </p><p>开启socks5代理方式</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D  0.0.0.0:8888 username@127.0.0.1 -N -oPort=6000</span><br></pre></td></tr></tbody></table></figure><ul><li>username  是内网机器的用户名</li><li>oPort是本机frpc配置中的bind_port</li></ul><p>这样配置以后就可以访问了. </p><p>如果需要访问内网中的数据库的话, 一般可以借助连接工具, 如<code>navicat</code>一般都会带ssh隧道的连接方式</p><p>下面是navicat的配置方式</p><p><img src="https://gitee.com/yu_binbin/personnal-image/raw/master/mongo1.png" alt="mongo1"></p><p><img src="https://gitee.com/yu_binbin/personnal-image/raw/master/mongo2.png" alt="mongo2"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>frp在windows上会报毒, 我这次是通过下载其他安全软件覆盖掉默认的windows defender,  这次怎么都关不掉windows这个流氓软件(注册表等手段试过都无效), 只能以毒攻毒, 用其他杀毒软件. </li><li>服务端需要启用相应的转发端口. </li><li>windows上的sshd需要自行安装</li><li>windows如果需要远程, 需要开启远程桌面功能, 才能进行自带的远程连接功能.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://sspai.com/post/52523">使用frp进行内网穿透</a></li><li><a href="https://gofrp.org/docs/">官网</a></li><li><a href="https://lo-li.cn/239">windows上frp开机自启</a></li><li><a href="https://zhuanlan.zhihu.com/p/57630633">ssh登录外的其他功能</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">ssh端口转发</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于frp进行内网穿透&quot;&gt;&lt;a href=&quot;#基于frp进行内网穿透&quot; class=&quot;headerlink&quot; title=&quot;基于frp进行内网穿透&quot;&gt;&lt;/a&gt;基于&lt;code&gt;frp&lt;/code&gt;进行内网穿透&lt;/h2&gt;&lt;p&gt;公司的数据库环境,服务器环境都是内网环境,</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="远程连接" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>搭建frp内网穿透工具</title>
    <link href="http://example.com/2021/04/28/other/%E6%90%AD%E5%BB%BAfrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2021/04/28/other/%E6%90%AD%E5%BB%BAfrp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2022-09-13T06:14:27.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建frp内网穿透工具"><a href="#搭建frp内网穿透工具" class="headerlink" title="搭建frp内网穿透工具"></a>搭建frp内网穿透工具</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取源码文件</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.36.2/frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf frp_0.36.2_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名</span></span><br><span class="line"><span class="built_in">mv</span> frp_0.36.2_linux_amd64 frp</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动补全命令</span></span><br><span class="line"></span><br><span class="line">curl -L http://hengyunabc.github.io/bash_completion_install.sh | sh</span><br><span class="line"><span class="built_in">bind</span> -f  ~/.inputrc</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;搭建frp内网穿透工具&quot;&gt;&lt;a href=&quot;#搭建frp内网穿透工具&quot; class=&quot;headerlink&quot; title=&quot;搭建frp内网穿透工具&quot;&gt;&lt;/a&gt;搭建frp内网穿透工具&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="frp" scheme="http://example.com/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu远程连接windows电脑</title>
    <link href="http://example.com/2021/04/26/linux/ubuntu_remote_connect/"/>
    <id>http://example.com/2021/04/26/linux/ubuntu_remote_connect/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于freerdp远程连接"><a href="#基于freerdp远程连接" class="headerlink" title="基于freerdp远程连接"></a>基于freerdp远程连接</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因工作需要, 需要使用<code>ubuntu</code>连接远程Windows电脑. 在windows电脑上使用向日葵等远程连接软件十分方便, 在<code>ubuntu</code>上当然也有对应的软件可以使用, 这款软件就是 <code>freerdp</code>. </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>虽然有apt-get的方式可以直接安装, 但是这个好像不支持密码为空的连接方式, 就直接使用源码进行安装. </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update -y  # 这步必须要做, 不然可能依赖不能下载完全</span><br><span class="line"></span><br><span class="line">sudo apt-get install git cmake cdbs zlib1g-dev libssl-dev libglib2.0-dev libxml2-dev libxext-dev libsystemd-dev libwayland-dev libxkbcommon-dev libasound2-dev libpulse-dev libcups2-dev libpcsclite-dev libavcodec-dev libavutil-dev libavresample-dev libswresample-dev libxkbfile-dev libxinerama-dev libxcursor-dev libxv-dev libxi-dev libxrandr-dev docbook-xsl libcairo2-dev xsltproc libusb-1.0-0-dev -y</span><br><span class="line"></span><br><span class="line">sudo git clone git://github.com/FreeRDP/FreeRDP.git --branch 2.2.0</span><br><span class="line"></span><br><span class="line">cd FreeRDP</span><br><span class="line"></span><br><span class="line">sudo cmake -DTARGET_ARCH=ARM -DWITH_X11=ON</span><br><span class="line"></span><br><span class="line">sudo make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></tbody></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装成功输入<code>xfreerdp</code>出来软件的帮助信息后, 说明安装成功</p><p>这个命令的参数有点多, 可以直接参考help, 这里只介绍几个参数的作用</p><ul><li><p><strong>/v</strong> 主机<code>ip</code>和地址 形式如 <code>/v:192.168.1.100:4489</code></p></li><li><p><strong>/p</strong> 密码 </p></li><li><p><strong>/u</strong> 用户名</p></li><li><p><strong>/f</strong> 全屏</p></li><li><p><strong>/bpp</strong>  色彩度指定, 当网络速度不快时, 或者需要降低延迟, 这个值可以指定的比较小</p></li><li><p><strong>/drive</strong>  指定挂载主机的目录, 会在远程主机中出现一个虚拟目录, 这个目录用来互相传送文件. 使用方式例如 <code>/drive:Mount,/home/yscl/</code> 这里的mount指的是挂载的目录名字</p></li><li><p><strong>/w</strong>  宽度width</p></li><li><p><strong>/h</strong> 高度height</p></li></ul><p>使用demo</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /u:JohnDoe /p:Pwd123! /w:1366 /h:768 /v:192.168.1.100:4489</span><br><span class="line"></span><br><span class="line"> xfreerdp /v:127.0.0.1 /u:Administrator /p: /f /bpp:8</span><br><span class="line"> </span><br><span class="line"> xfreerdp /u:litai /p:123 /w:1366 /h:768 /v:127.0.0.1:3389 /drive:Mount,/home/yscl/Project/Work/litai/backend/dev</span><br></pre></td></tr></tbody></table></figure><p>说明一句, windows的远程访问端口为3389, 当我们连接成功后, 可以按<code>crtl+ alt +enter</code> 退出全屏</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.raspberrypi.org/forums/viewtopic.php?t=292360">https://www.raspberrypi.org/forums/viewtopic.php?t=292360</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于freerdp远程连接&quot;&gt;&lt;a href=&quot;#基于freerdp远程连接&quot; class=&quot;headerlink&quot; title=&quot;基于freerdp远程连接&quot;&gt;&lt;/a&gt;基于freerdp远程连接&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="远程连接" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose搭建mongo集群</title>
    <link href="http://example.com/2021/04/16/mongo/docker_cluster/"/>
    <id>http://example.com/2021/04/16/mongo/docker_cluster/</id>
    <published>2021-04-15T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<boxx><h2 id="使用docker-compose搭建mongo集群"><a href="#使用docker-compose搭建mongo集群" class="headerlink" title="使用docker-compose搭建mongo集群"></a>使用docker-compose搭建mongo集群</h2><p>参考github上的docker-compose搭建mongo集群链接： <a href="https://github.com/minhhungit/mongodb-cluster-docker-compose">https://github.com/minhhungit/mongodb-cluster-docker-compose</a> </p><p>记一下搭建与学习过程， 顺便再学习记录下docker-compose的写法。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>mongodb集群搭建方式通常有3种：</p><ol><li>主从（Master - Slave）模式</li><li>副本集（Replica Set）模式</li><li>分片（Sharding）模式</li></ol><p>这次采用的是Replica Set +  Sharding的模式来搭建的高可用的mongo集群， 下图是github上集群的架构。</p><p><img src="https://gitee.com/yu_binbin/personnal-image/raw/master/sharding-and-replica-sets.png" alt="sharding-and-replica-sets"></p><p>依照架构图， 这次集群的配置如下：</p><ul><li>配置服务器（Config Server ）由3个配置服务器组成一个<code>replica set</code>， 对应configsvr01<code>,</code>configsvr02<code>,</code>configsvr03</li><li>3个Shard节点， 每个shard节点又是由3个shard服务器组成的一个<code>replica set</code>对应如下：<ul><li><code>shard01-a</code>,<code>shard01-b</code>, <code>shard01-c</code></li><li><code>shard02-a</code>,<code>shard02-b</code>, <code>shard02-c</code></li><li><code>shard03-a</code>,<code>shard03-b</code>, <code>shard03-c</code></li></ul></li><li>2个路由(Routers) mongos服务器: <code>router01</code>, <code>router02</code></li></ul><p>构建一个 mongoDB Sharding Cluster 需要三种角色:shard 服务器(ShardServer)、配置服务器(config Server)、路由进程(Route Process)</p><p>构建一个 mongoDB Sharding Cluster 需要三种角色:shard 服务器(ShardServer)、配置服务器(config Server)、路由进程(Route Process)</p><p><strong>shard 服务器</strong></p><p>　　shard 服务器即存储实际数据的分片,每个 shard 可以是一个 mongod 实例, 也可以是一组 mongod 实例构成的 Replica Sets.为了实现每个 Shard 内部的故障 自动转换,MongoDB 官方建议每个 shard 为一组 Replica Sets.</p><p><strong>配置服务器</strong></p><p>​         为了将一个特定的 collection 存储在多个 shard 中,需要为该 collection 指定 一个 shard key,决定该条记录属于哪个 chunk,配置服务器可以存储以下信息, 每个shard节点的配置信息,每个chunk的shard key范围,chunk在各shard 的分布情况,集群中所有 DB 和 collection 的 sharding 配置信息。</p><p><strong>路由进程（mongos）</strong></p><p>​         它是一个前端路由,客户端由此接入,首先询问配置服务器需要到哪个 shard 上查询或保存记录,然后连接相应的 shard 执行操作,最后将结果返回给客户端,客户端只需要将原本发给 mongod 的查询或更新请求原封不动地发给路由进程,而不必关心所操作的记录存储在哪个 shard 上。</p><h3 id="docker-compose配置"><a href="#docker-compose配置" class="headerlink" title="docker-compose配置"></a>docker-compose配置</h3><blockquote><p> docker-compose.yml</p></blockquote><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Router</span></span><br><span class="line">  <span class="attr">router01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-router-01</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongos</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configdb</span> <span class="string">rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017</span> <span class="string">--bind_ip_all</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27117</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">  <span class="attr">router02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-router-02</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongos</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configdb</span> <span class="string">rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017</span> <span class="string">--bind_ip_all</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27118</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">router01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Config Servers</span></span><br><span class="line">  <span class="attr">configsvr01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-01</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27119</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-a</span></span><br><span class="line">  <span class="attr">configsvr02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-02</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27120</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configsvr01</span></span><br><span class="line">  <span class="attr">configsvr03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-03</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27121</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configsvr02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Shards</span></span><br><span class="line">  <span class="comment">## Shards 01</span></span><br><span class="line">   </span><br><span class="line">  <span class="attr">shard01-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27122</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-c</span></span><br><span class="line">  <span class="attr">shard01-b:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-b</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27123</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">shard01-c:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-c</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27124</span><span class="string">:27017</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Shards 02</span></span><br><span class="line">  <span class="attr">shard02-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-02-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-02</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27125</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-c</span></span><br><span class="line">  <span class="attr">shard02-b:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-02-node-b</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-02</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27126</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">shard02-c:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-02-node-c</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-02</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27127</span><span class="string">:27017</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Shards 03</span></span><br><span class="line">  <span class="attr">shard03-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-03-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-03</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27128</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-c</span></span><br><span class="line">  <span class="attr">shard03-b:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-03-node-b</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-03</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27129</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">shard03-c:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-03-node-c</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-03</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27130</span><span class="string">:27017</span></span><br></pre></td></tr></tbody></table></figure><p>整个docker-compose文件组要分成3大块， 对应于mongo集群的3个组件</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a><strong>Router</strong></h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">router01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-router-01</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongos</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configdb</span> <span class="string">rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017</span> <span class="string">--bind_ip_all</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27117</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br></pre></td></tr></tbody></table></figure><p>上面是<code>router01</code>的配置， 简单解读下</p><p>服务名为router01，启动容器使用的镜像为mongo:4.0， 启动后的容器名字是<code>rydell-router-01</code>， 容器启动后绑定的端口号为宿主机：容器（27117:27017）,  数据文件夹， 将容器内部的scripts文件夹挂载到当前目录的scripts文件夹下， 这里还可以配置mongo的配置文件，数据文件夹等的挂载目录。command参数表示容器启动后执行的命令：</p><p><code>mongos --port 27017 --configdb rs-config-server/configsvr01:27017,configsvr02:27017,configsvr03:27017 --bind_ip_all</code></p><p>上面的命令涉及到几个配置， 具体的使用方式可以参考<a href="https://docs.mongodb.com/manual/reference/program/mongos/">mongodb官网</a></p><p><strong>–port:</strong> mongos启动监听的端口号</p><p><strong>–configdb:</strong>  指定集群的配置服务器 指定格式是<code>--configdb &lt;replicasetName&gt;/&lt;config1&gt;,&lt;config2&gt;...</code></p><p>需要指定配置服务器组成的<code>replica set</code>的名字以及配置服务器的ip和port</p><p><strong>–bind_ip_all:</strong> 监听所有ip的连接， 相当于<code>--bind_ip 0.0.0.0</code></p><p>上面配置的时候直接以服务名作为host， 这个涉及到docker-compose的网络配置。 在docker-compose启动后， 会创建以docker-compose文件<code>所在文件夹名字_default</code>的网络， 然后文件中的服务启动后，会以服务名加入这个网络，这样容器之间可以使用服务名称作为hostname相互访问。网络的具体解析可以参考这篇博客” <a href="https://juejin.cn/post/6844903976534540296">Docker Compose 网络设置</a> “， 写得非常详细.</p><h4 id="Config-Servers"><a href="#Config-Servers" class="headerlink" title="Config Servers"></a><strong>Config Servers</strong></h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configsvr01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-mongo-config-01</span> </span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--configsvr</span> <span class="string">--replSet</span> <span class="string">rs-config-server</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27119</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard02-a</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard03-a</span></span><br></pre></td></tr></tbody></table></figure><p>这里只看容器启动后执行的命令 <code>mongod --port 27017 --configsvr --replSet rs-config-server</code></p><p>这里的使用方式可以参考<a href="https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/#start-each-member-of-the-config-server-replica-set">官方文档开启配置服务器</a></p><p><strong>–replSet</strong>  指定一个<code>Replica Set</code>的名字，集合内所有服务器必须拥有相同的名字</p><p><strong>–configsvr</strong> 启动一个配置服务器必须要指定的参数</p><h4 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a><strong>Shard</strong></h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shard01-a:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rydell-shard-01-node-a</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--port</span> <span class="number">27017</span> <span class="string">--shardsvr</span> <span class="string">--replSet</span> <span class="string">rs-shard-01</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/scripts</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27122</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-b</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">shard01-c</span></span><br></pre></td></tr></tbody></table></figure><p>还是只看容器启动后执行的命令 <code>mongod --port 27017 --shardsvr --replSet rs-shard-01</code></p><p><strong>–replSet</strong>  指定一个<code>Replica Set</code>的名字，集合内所有服务器必须拥有相同的名字</p><p><strong>–shardsvr</strong> 启动一个shard服务器必须要指定的参数</p><h3 id="集群初始化"><a href="#集群初始化" class="headerlink" title="集群初始化"></a>集群初始化</h3><p>上面执行<code>docker-compose up -d</code>的命令后已经启动了mongo集群的3个组件， 集群还需要进行初始化操作。</p><p><strong>初始化配置服务器</strong></p><p><code>docker-compose exec configsvr01 sh -c "mongo &lt; /scripts/init-configserver.js"</code></p><p><code>init-configserver.js</code>脚本文件内容如下所示</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">initiate</span>( {</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">"rs-config-server"</span>, </span><br><span class="line">    <span class="attr">configsvr</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">version</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">members</span>: [</span><br><span class="line">         { <span class="attr">_id</span>: <span class="number">0</span>, host : <span class="string">'configsvr01:27017'</span> },</span><br><span class="line">         { <span class="attr">_id</span>: <span class="number">1</span>, host : <span class="string">'configsvr02:27017'</span> }, </span><br><span class="line">         { <span class="attr">_id</span>: <span class="number">2</span>, host : <span class="string">'configsvr03:27017'</span> } </span><br><span class="line">     ] })</span><br></pre></td></tr></tbody></table></figure><p>上面是通过docker-compose 的exec命令进入到容器内部执行命令， 相当于docker原生命令<code>docker exec -it $DOCKER_ID /bin/bash -c 'command'</code></p><p>这条命令的主要作用就是先连接任意一个配置服务器， 然后初始化<code>replica set</code>， 上面的参数</p><ul><li>_id:   <code>replica set</code>名字</li><li>configsvr： 如果是配置服务器， 就指定为true</li><li>members： 集合内成员的id和host配置</li><li>version： 版本号</li></ul><p>更多的<code>replica set</code>配置可以参考<a href="https://docs.mongodb.com/manual/reference/replica-configuration/">官方文档<code>replica set</code>配置部分</a></p><p><strong>初始化每个shard服务器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec shard01-a sh -c "mongo &lt; /scripts/init-shard01.js"</span><br><span class="line">docker-compose exec shard02-a sh -c "mongo &lt; /scripts/init-shard02.js"</span><br><span class="line">docker-compose exec shard03-a sh -c "mongo &lt; /scripts/init-shard03.js"</span><br></pre></td></tr></tbody></table></figure><p>上面三个脚本的内容类似， 下面是init-shard01.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rs.<span class="title function_">initiate</span>({</span><br><span class="line">    <span class="attr">_id</span>: <span class="string">"rs-shard-01"</span>,</span><br><span class="line">    <span class="attr">version</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">members</span>: [</span><br><span class="line">        {<span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">host</span>: <span class="string">"shard01-a:27017"</span>}, </span><br><span class="line">        {<span class="attr">_id</span>: <span class="number">1</span>, <span class="attr">host</span>: <span class="string">"shard01-b:27017"</span>}, </span><br><span class="line">        {<span class="attr">_id</span>: <span class="number">2</span>, <span class="attr">host</span>: <span class="string">"shard01-c:27017"</span>}</span><br><span class="line">    ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>还是初始化shard节点组成的<code>replica set</code>， 指定成员之类的操作。</p><p><strong>初始化路由(mongos)</strong></p><blockquote><p> 执行下面的操作之前需要稍微等待一会， 因为配置服务器和shard服务器需要先互相通信选取主节点</p></blockquote><p>执行<code>docker-compose exec router01 sh -c "mongo &lt; /scripts/init-router.js"</code></p><p>init-router.js文件内容如下所示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-01/shard01-a:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-01/shard01-b:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-01/shard01-c:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-02/shard02-a:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-02/shard02-b:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-02/shard02-c:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-03/shard03-a:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-03/shard03-b:27017"</span>)</span><br><span class="line">sh.<span class="title function_">addShard</span>(<span class="string">"rs-shard-03/shard03-c:27017"</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面的命令先连接到集群中， 我们连接连接集群主要需要与mongos服务器打交道，所以先连接任意一个路由进程， 将shard节点添加进去</p><p>添加shard节点方法参数：<code>sh.addShard("&lt;replica_set&gt;/&lt;hostname&gt;&lt;:port&gt;")</code></p><h3 id="开启分片"><a href="#开启分片" class="headerlink" title="开启分片"></a>开启分片</h3><p>在对表分片之前， 必须开启数据库的分片功能， 这行命令是<code>sh.enableSharding("&lt;database&gt;")</code>. 表示对指定的数据库进行分片</p><p>对数据库指定需要开启分片功能, 然后需要指定该数据库下某张表执行分片的依据. 即指定<code>sharding key</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.<span class="title function_">shardCollection</span>(<span class="string">"&lt;database&gt;.&lt;collection&gt;"</span>, { <span class="language-xml"><span class="tag">&lt;<span class="name">shard</span> <span class="attr">key</span> <span class="attr">field</span>&gt;</span> : "hashed" } )</span></span><br></pre></td></tr></tbody></table></figure><p>或者使用demo中例子的命令: </p><p><code>db.adminCommand( { shardCollection: "MyDatabase.MyCollection", key: { supplierId: "hashed" } } )</code>含义与上面一致.</p><p>至此, mongo集群的搭建就已经基本成功了, 接下来的操作就是连接上mongos服务器, 插入数据来进行测试了. </p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/minhhungit/mongodb-cluster-docker-compose">https://github.com/minhhungit/mongodb-cluster-docker-compose</a></li><li><a href="https://segmentfault.com/a/1190000023144572?utm_source=sf-similar-article">基于docker容器下mongodb 4.0.0 的Replica Sets+Sharded Cluster集群</a></li><li><a href="https://blog.csdn.net/quanmaoluo5461/article/details/85164588#t15">Docker搭建高可用的mongodb副本集+分片</a></li><li><a href="https://segmentfault.com/a/1190000039142073">https://segmentfault.com/a/1190000039142073</a></li></ul></boxx>]]></content>
    
    
      
      
    <summary type="html">&lt;boxx&gt;

&lt;h2 id=&quot;使用docker-compose搭建mongo集群&quot;&gt;&lt;a href=&quot;#使用docker-compose搭建mongo集群&quot; class=&quot;headerlink&quot; title=&quot;使用docker-compose搭建mongo集群&quot;&gt;&lt;/a&gt;使用d</summary>
      
    
    
    
    <category term="mongo" scheme="http://example.com/categories/mongo/"/>
    
    
    <category term="集群" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
    <category term="mongo" scheme="http://example.com/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>application_初始化阅读</title>
    <link href="http://example.com/2021/03/25/tornado/source_read/application_read/"/>
    <id>http://example.com/2021/03/25/tornado/source_read/application_read/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里开始从<code>HelloWorld</code>的demo开始阅读源码。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">        (<span class="string">r'/'</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">app.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></tbody></table></figure><p>上面三行代码是先从实例化一个<code>webApp</code>开始的， 那么接下来开始看这个Application的源码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>(<span class="title class_ inherited__">ReversibleRouter</span>):</span><br><span class="line">    <span class="string">r"""A collection of request handlers that make up a web application.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Instances of this class are callable and can be passed directly to</span></span><br><span class="line"><span class="string">    HTTPServer to serve the application::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        application = web.Application([</span></span><br><span class="line"><span class="string">            (r"/", MainPageHandler),</span></span><br><span class="line"><span class="string">        ])</span></span><br><span class="line"><span class="string">        http_server = httpserver.HTTPServer(application)</span></span><br><span class="line"><span class="string">        http_server.listen(8080)</span></span><br><span class="line"><span class="string">        ioloop.IOLoop.current().start()</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        handlers: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        default_host: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        transforms: <span class="type">Optional</span>[<span class="type">List</span>[<span class="type">Type</span>[<span class="string">"OutputTransform"</span>]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **settings: <span class="type">Any</span></span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param handlers: 处理业务逻辑的包含路由设置的handlers</span></span><br><span class="line"><span class="string">        :param default_host: 默认的启动后的host</span></span><br><span class="line"><span class="string">        :param transforms: 设置响应结果传输的方式</span></span><br><span class="line"><span class="string">        :param settings:  application的配置</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置了transforms参数会在响应头中添加Content-Encoding='gzip'</span></span><br><span class="line">        <span class="keyword">if</span> transforms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.transforms = []  <span class="comment"># type: <span class="type">List</span>[<span class="type">Type</span>[OutputTransform]]</span></span><br><span class="line">            <span class="comment"># 如果需要压缩响应结果， 需要在结果中设置compress_response或gzip参数为True</span></span><br><span class="line">            <span class="keyword">if</span> settings.get(<span class="string">"compress_response"</span>) <span class="keyword">or</span> settings.get(<span class="string">"gzip"</span>):</span><br><span class="line">                self.transforms.append(GZipContentEncoding)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.transforms = transforms</span><br><span class="line">        <span class="comment"># 默认host</span></span><br><span class="line">        self.default_host = default_host</span><br><span class="line">        <span class="comment"># 加载所有初始化后传入的settings</span></span><br><span class="line">        self.settings = settings</span><br><span class="line">        <span class="comment"># 模板相关的配置</span></span><br><span class="line">        self.ui_modules = {</span><br><span class="line">            <span class="string">"linkify"</span>: _linkify,</span><br><span class="line">            <span class="string">"xsrf_form_html"</span>: _xsrf_form_html,</span><br><span class="line">            <span class="string">"Template"</span>: TemplateModule,</span><br><span class="line">        }</span><br><span class="line">        self.ui_methods = {}  <span class="comment"># type: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Callable</span>[..., <span class="built_in">str</span>]]</span></span><br><span class="line">        <span class="comment"># 获取自定义的UIModule和UIMethods</span></span><br><span class="line">        self._load_ui_modules(settings.get(<span class="string">"ui_modules"</span>, {}))</span><br><span class="line">        self._load_ui_methods(settings.get(<span class="string">"ui_methods"</span>, {}))</span><br><span class="line">        <span class="comment"># 检查settings有没有配置静态资源的路径</span></span><br><span class="line">        <span class="keyword">if</span> self.settings.get(<span class="string">"static_path"</span>):</span><br><span class="line">            path = self.settings[<span class="string">"static_path"</span>]</span><br><span class="line">            handlers = <span class="built_in">list</span>(handlers <span class="keyword">or</span> [])</span><br><span class="line">            <span class="comment"># 默认的静态资源路径为/static/资源的地址</span></span><br><span class="line">            static_url_prefix = settings.get(<span class="string">"static_url_prefix"</span>, <span class="string">"/static/"</span>)</span><br><span class="line">            <span class="comment"># 静态资源的处理Handler， 可以自己传，也可以使用默认的Handler</span></span><br><span class="line">            static_handler_class = settings.get(</span><br><span class="line">                <span class="string">"static_handler_class"</span>, StaticFileHandler</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># static_handler_args参数是传递给文件处理Handler执行initialize函数初始化的参数</span></span><br><span class="line">            static_handler_args = settings.get(<span class="string">"static_handler_args"</span>, {})</span><br><span class="line">            static_handler_args[<span class="string">"path"</span>] = path</span><br><span class="line">            <span class="comment"># 默认会添加3条静态资源相关的路由地址</span></span><br><span class="line">            <span class="keyword">for</span> pattern <span class="keyword">in</span> [</span><br><span class="line">                re.escape(static_url_prefix) + <span class="string">r"(.*)"</span>,</span><br><span class="line">                <span class="string">r"/(favicon\.ico)"</span>,</span><br><span class="line">                <span class="string">r"/(robots\.txt)"</span>,</span><br><span class="line">            ]:</span><br><span class="line">                handlers.insert(<span class="number">0</span>, (pattern, static_handler_class, static_handler_args))</span><br><span class="line">        <span class="comment"># 检查是否配置是debug模式</span></span><br><span class="line">        <span class="keyword">if</span> self.settings.get(<span class="string">"debug"</span>):</span><br><span class="line">            <span class="comment"># 自动重载</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"autoreload"</span>, <span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 取消编译模板缓存</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"compiled_template_cache"</span>, <span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># 取消静态文件的hash值缓存</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"static_hash_cache"</span>, <span class="literal">False</span>)</span><br><span class="line">            <span class="comment"># 提供处理跟踪信息</span></span><br><span class="line">            self.settings.setdefault(<span class="string">"serve_traceback"</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加路由， 这个也是这个app最重要的一个部分</span></span><br><span class="line">        self.wildcard_router = _ApplicationRouter(self, handlers)</span><br><span class="line">        self.default_router = _ApplicationRouter(</span><br><span class="line">            self, [Rule(AnyMatches(), self.wildcard_router)]</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 自动重载</span></span><br><span class="line">        <span class="comment"># Automatically reload modified modules</span></span><br><span class="line">        <span class="keyword">if</span> self.settings.get(<span class="string">"autoreload"</span>):</span><br><span class="line">            <span class="keyword">from</span> tornado <span class="keyword">import</span> autoreload</span><br><span class="line"></span><br><span class="line">            autoreload.start()</span><br><span class="line">        </span><br></pre></td></tr></tbody></table></figure><p>跟踪上面的<code>_ApplicationRouter</code>类代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_ApplicationRouter</span>(<span class="title class_ inherited__">ReversibleRuleRouter</span>):</span><br><span class="line">    <span class="string">"""Routing implementation used internally by `Application`.</span></span><br><span class="line"><span class="string">这是一个用来绑定应用程序和RequestHandler的类， 通过路由建立桥梁。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, application: <span class="string">"Application"</span>, rules: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(application, Application)</span><br><span class="line">        self.application = application</span><br><span class="line">        <span class="built_in">super</span>().__init__(rules)</span><br></pre></td></tr></tbody></table></figure><p>上面这个类继承自<code>ReversibleRuleRouter</code>， 继续跟踪代码往下。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReversibleRuleRouter</span>(ReversibleRouter, RuleRouter):</span><br><span class="line">    <span class="string">"""A rule-based router that implements ``reverse_url`` method.</span></span><br><span class="line"><span class="string">这个类实现了反向解析类reverse_url方法， 这个功能一般是在模板里面使用的，能够根据名字反向解析出url</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rules: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.named_rules = {}  <span class="comment"># type: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(rules)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_rule</span>(<span class="params">self, rule: <span class="string">"Rule"</span></span>) -&gt; <span class="string">"Rule"</span>:</span><br><span class="line">        rule = <span class="built_in">super</span>().process_rule(rule)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rule.name:</span><br><span class="line">            <span class="keyword">if</span> rule.name <span class="keyword">in</span> self.named_rules:</span><br><span class="line">                app_log.warning(</span><br><span class="line">                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>, rule.name</span><br><span class="line">                )</span><br><span class="line">            <span class="comment"># 将路由的名字与对应的rule规则映射起来。    </span></span><br><span class="line">            self.named_rules[rule.name] = rule</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rule</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_url</span>(<span class="params">self, name: <span class="built_in">str</span>, *args: <span class="type">Any</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">"""反向解析功能的实现（根据名字来获取映射的url）"""</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.named_rules:</span><br><span class="line">            <span class="keyword">return</span> self.named_rules[name].matcher.reverse(*args)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> self.rules:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(rule.target, ReversibleRouter):</span><br><span class="line">                reversed_url = rule.target.reverse_url(name, *args)</span><br><span class="line">                <span class="keyword">if</span> reversed_url <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> reversed_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><p>看到这里上面的这个类还是还是没有真正的添加路由规则， 它还继承了另一个核心类<code>RuleRouter</code>， 继续跟踪下去。 </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RuleRouter</span>(<span class="title class_ inherited__">Router</span>):</span><br><span class="line">    <span class="string">"""Rule-based router implementation."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rules: <span class="type">Optional</span>[_RuleList] = <span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""Constructs a router from an ordered list of rules::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            RuleRouter([</span></span><br><span class="line"><span class="string">                Rule(PathMatches("/handler"), Target),</span></span><br><span class="line"><span class="string">                # ... more rules</span></span><br><span class="line"><span class="string">            ])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        You can also omit explicit `Rule` constructor and use tuples of arguments::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            RuleRouter([</span></span><br><span class="line"><span class="string">                (PathMatches("/handler"), Target),</span></span><br><span class="line"><span class="string">            ])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        `PathMatches` is a default matcher, so the example above can be simplified::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            RuleRouter([</span></span><br><span class="line"><span class="string">                ("/handler", Target),</span></span><br><span class="line"><span class="string">            ])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        In the examples above, ``Target`` can be a nested `Router` instance, an instance of</span></span><br><span class="line"><span class="string">        `~.httputil.HTTPServerConnectionDelegate` or an old-style callable,</span></span><br><span class="line"><span class="string">        accepting a request argument.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg rules: a list of `Rule` instances or tuples of `Rule`</span></span><br><span class="line"><span class="string">            constructor arguments.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.rules = []  <span class="comment"># type: <span class="type">List</span>[Rule]</span></span><br><span class="line">        <span class="keyword">if</span> rules:</span><br><span class="line">            <span class="comment"># 这里是真正的添加规则</span></span><br><span class="line">            self.add_rules(rules)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_rules</span>(<span class="params">self, rules: _RuleList</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""Appends new rules to the router.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg rules: a list of Rule instances (or tuples of arguments, which are</span></span><br><span class="line"><span class="string">            passed to Rule constructor).</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> rules:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(rule, (<span class="built_in">tuple</span>, <span class="built_in">list</span>)):</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">len</span>(rule) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(rule[<span class="number">0</span>], basestring_type):</span><br><span class="line">                    rule = Rule(PathMatches(rule[<span class="number">0</span>]), *rule[<span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rule = Rule(*rule)</span><br><span class="line"></span><br><span class="line">            self.rules.append(self.process_rule(rule))</span><br></pre></td></tr></tbody></table></figure><p>看到这里其实已经豁然开朗了， 最终会把规则放入<code>_ApplicationRouter</code>对象的<code>rules</code>属性中， 就是app的<code>wildcard_router</code>属性中可以直接获取到。 </p><p>接下来可以看看Rule对象的具体结构， 这个Rule对象保存了路由规则以及target处理的映射关系。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">"""A routing rule."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        matcher: <span class="string">"Matcher"</span>,</span></span><br><span class="line"><span class="params">        target: <span class="type">Any</span>,</span></span><br><span class="line"><span class="params">        target_kwargs: <span class="type">Optional</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""Constructs a Rule instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :arg Matcher matcher: a `Matcher` instance used for determining</span></span><br><span class="line"><span class="string">            whether the rule should be considered a match for a specific</span></span><br><span class="line"><span class="string">            request.</span></span><br><span class="line"><span class="string">        :arg target: a Rule's target (typically a ``RequestHandler`` or</span></span><br><span class="line"><span class="string">            `~.httputil.HTTPServerConnectionDelegate` subclass or even a nested `Router`,</span></span><br><span class="line"><span class="string">            depending on routing implementation).</span></span><br><span class="line"><span class="string">        :arg dict target_kwargs: a dict of parameters that can be useful</span></span><br><span class="line"><span class="string">            at the moment of target instantiation (for example, ``status_code``</span></span><br><span class="line"><span class="string">            for a ``RequestHandler`` subclass). They end up in</span></span><br><span class="line"><span class="string">            ``target_params['target_kwargs']`` of `RuleRouter.get_target_delegate`</span></span><br><span class="line"><span class="string">            method.</span></span><br><span class="line"><span class="string">        :arg str name: the name of the rule that can be used to find it</span></span><br><span class="line"><span class="string">            in `ReversibleRouter.reverse_url` implementation.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(target, <span class="built_in">str</span>):</span><br><span class="line">            <span class="comment"># import the Module and instantiate the class</span></span><br><span class="line">            <span class="comment"># Must be a fully qualified name (module.ClassName)</span></span><br><span class="line">            target = import_object(target)</span><br><span class="line"></span><br><span class="line">        self.matcher = matcher  <span class="comment"># type: Matcher</span></span><br><span class="line">        self.target = target</span><br><span class="line">        self.target_kwargs = target_kwargs <span class="keyword">if</span> target_kwargs <span class="keyword">else</span> {}</span><br><span class="line">        self.name = name</span><br></pre></td></tr></tbody></table></figure><p>一条路由规则组成结构还是比较简单的， 一共就4部分， 上面的英文文档其实已经说的比较清楚了</p><ul><li>matcher  其实就是在我们写的正则路由中包装了一层</li><li>target   request请求开始后路由到对应的target对象去处理， 这个target对象可以是典型的<code>RequestHandler</code>或是<code>httputil.HTTPServerConnectionDelegate</code>的实现类或是还可以是一个嵌套的<code>Router</code>类实例</li><li>target_kwargs  顾名思义， 就是给target（请求处理对象）的参数</li><li>name   路由反向解析的名字</li></ul><p>到这也基本可以明白一个app初始化后， 主要就是一些内部参数的初始化， 以及最重要的路由绑定等等处理。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里开始从&lt;code&gt;HelloWorld&lt;/code&gt;的demo开始阅读源码。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="tornado" scheme="http://example.com/categories/tornado/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>启动httpserver</title>
    <link href="http://example.com/2021/03/25/tornado/source_read/start_httpserver/"/>
    <id>http://example.com/2021/03/25/tornado/source_read/start_httpserver/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>看看启动server的代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">        (<span class="string">r'/'</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">app.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></tbody></table></figure><p>第一行代码只是简单的初始化了应用<code>app</code>， 而没有实际启动<code>httpserver </code>， 下面分析如何启动<code>httpsever</code>的。 </p><p>进入源码分析</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self, port: <span class="built_in">int</span>, address: <span class="built_in">str</span> = <span class="string">""</span>, **kwargs: <span class="type">Any</span></span>) -&gt; HTTPServer:</span><br><span class="line">    <span class="string">"""Starts an HTTP server for this application on the given port.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is a convenience alias for creating an `.HTTPServer`</span></span><br><span class="line"><span class="string">    object and calling its listen method.  Keyword arguments not</span></span><br><span class="line"><span class="string">    supported by `HTTPServer.listen &lt;.TCPServer.listen&gt;` are passed to the</span></span><br><span class="line"><span class="string">    `.HTTPServer` constructor.  For advanced uses</span></span><br><span class="line"><span class="string">    (e.g. multi-process mode), do not use this method; create an</span></span><br><span class="line"><span class="string">    `.HTTPServer` and call its</span></span><br><span class="line"><span class="string">    `.TCPServer.bind`/`.TCPServer.start` methods directly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that after calling this method you still need to call</span></span><br><span class="line"><span class="string">    ``IOLoop.current().start()`` to start the server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns the `.HTTPServer` object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 4.3</span></span><br><span class="line"><span class="string">       Now returns the `.HTTPServer` object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    server = HTTPServer(self, **kwargs)  <span class="comment"># 把当前app和HttpServer进行绑定</span></span><br><span class="line">    server.listen(port, address)</span><br><span class="line">    <span class="keyword">return</span> server</span><br></pre></td></tr></tbody></table></figure><p>上面零零洒洒的注释大致也说明了这个<code>app.listen</code>是一个启动<code>HttpServer</code>的快捷方式。 但是提到了一句，如果需要使用多进程模式， 就不能使用当前这种方法了。 </p><p>当然， 使用了<code>app.listen</code>方法后还需要启动IO循环才算真正的启动了<code>http</code>服务器。</p><p>上面的<code>HTTPServer</code>内部这里先不进去深入探究， 后续再深入探究</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看看启动server的代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="tornado" scheme="http://example.com/categories/tornado/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>tornado官方demo</title>
    <link href="http://example.com/2021/03/25/tornado/source_read/tornado_demo/"/>
    <id>http://example.com/2021/03/25/tornado/source_read/tornado_demo/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>tornado框架初体验， 永远的<code>hello world</code></p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>在官方基础demo上加了一些执行顺序的代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, Awaitable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainHandler</span>(tornado.web.RequestHandler):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prepare</span>(<span class="params">self</span>) -&gt; <span class="type">Optional</span>[Awaitable[<span class="literal">None</span>]]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'prepare....'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">self, database</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.database = database</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'initialize....'</span>, database)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_default_headers</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'set_default_headers...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_error</span>(<span class="params">self, status_code: <span class="built_in">int</span>, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'write_error...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_finish</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'on_finish...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'hello world...'</span>)</span><br><span class="line">        self.write(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_app</span>():</span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r'/'</span>, MainHandler, <span class="built_in">dict</span>(database=<span class="string">'mysql...'</span>)),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在浏览器上输入路由后， 清晰的看到执行顺序</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_default_headers...</span><br><span class="line">initialize.... mysql...</span><br><span class="line">prepare....</span><br><span class="line">hello world...</span><br><span class="line">on_finish...</span><br></pre></td></tr></tbody></table></figure><ol><li><code>set_default_headers()</code>设置默认返回头部的方法</li><li><code>initialize()</code>这个是类实例初始化会调用的方法，可以增加初始化的功能</li><li><code>prepare()</code>这个是预先处理方法，可以在处理HTTP请求的方法执行前调用进行一些预处理</li><li><code>HTTP方法</code>方法名为：get, post, head, delete, put, patch, options的方法，用来处理对应的HTTP方法的请求</li><li><code>on_finish()</code>结束请求的时候执行这个方法</li></ol><p>上面就是tornado的基础使用方式 ， 还是非常简单的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;tornado框架初体验， 永远的&lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h4&gt;&lt;p&gt;在官方基础demo上加了一</summary>
      
    
    
    
    <category term="tornado" scheme="http://example.com/categories/tornado/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>简化版异步框架</title>
    <link href="http://example.com/2021/03/25/tornado/source_read/simple_async_framework/"/>
    <id>http://example.com/2021/03/25/tornado/source_read/simple_async_framework/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-05-14T04:27:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境： 公司内部使用的web框架是基于tornado封装的， 为了快速熟悉框架与业务， 开始尝试阅读tornado源码， 来加速自己的成长。</p><h2 id="简化版的协程web框架"><a href="#简化版的协程web框架" class="headerlink" title="简化版的协程web框架"></a>简化版的协程web框架</h2><h3 id="简化版web框架核心代码"><a href="#简化版web框架核心代码" class="headerlink" title="简化版web框架核心代码"></a>简化版web框架核心代码</h3><p>来自《Python Cookbook》利用协程代替多线程来实现的网络并发框架，可以单线程执行多个网络请求的读和写。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">来源：Python cookbook， 使用协程模式来实现一个并发网络框架</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> select <span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># This class represents a generic yield event in the scheduler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldEvent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Task Scheduler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._numtasks = <span class="number">0</span>  <span class="comment"># Total num of tasks</span></span><br><span class="line">        self._ready = deque()  <span class="comment"># Tasks ready to run</span></span><br><span class="line">        self._read_waiting = {}  <span class="comment"># Tasks waiting to read</span></span><br><span class="line">        self._write_waiting = {}  <span class="comment"># Tasks waiting to write</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Poll for I/O events and restart waiting tasks</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_iopoll</span>(<span class="params">self</span>):</span><br><span class="line">        rset, wset, eset = select(self._read_waiting,</span><br><span class="line">                                  self._write_waiting, [])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> rset:</span><br><span class="line">            evt, task = self._read_waiting.pop(r)</span><br><span class="line">            evt.handle_resume(self, task)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wset:</span><br><span class="line">            evt, task = self._write_waiting.pop(w)</span><br><span class="line">            evt.handle_resume(self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">self, task</span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Add a newly started task to the scheduler</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        self._ready.append((task, <span class="literal">None</span>))</span><br><span class="line">        self._numtasks += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_ready</span>(<span class="params">self, task, msg=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Append an already started task to the ready queue.</span></span><br><span class="line"><span class="string">        msg is what to send into the task when it resumes.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._ready.append((task, msg))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a task to the reading set</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">        self._read_waiting[fileno] = (evt, task)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a task to the write set</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_write_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">        self._write_waiting[fileno] = (evt, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Run the task scheduler until there are no tasks</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self._numtasks:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._ready:</span><br><span class="line">                self._iopoll()</span><br><span class="line">            task, msg = self._ready.popleft()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Run the coroutine to the next yield</span></span><br><span class="line">                r = task.send(msg)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(r, YieldEvent):</span><br><span class="line">                    r.handle_yield(self, task)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> RuntimeError(<span class="string">'unrecognized yield event'</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self._numtasks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example implementation of coroutine-based socket I/O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock, nbytes</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line">        self.nbytes = nbytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        data = self.sock.recv(self.nbytes)</span><br><span class="line">        sched.add_ready(task, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock, data</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._write_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        nsent = self.sock.send(self.data)</span><br><span class="line">        sched.add_ready(task, nsent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AcceptSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        r = self.sock.accept()</span><br><span class="line">        sched.add_ready(task, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wrapper around a socket object for use with yield</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self._sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, maxbytes</span>):</span><br><span class="line">        <span class="keyword">return</span> ReadSocket(self._sock, maxbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> WriteSocket(self._sock, data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AcceptSocket(self._sock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._sock, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Example of a function involving generators.  This should</span></span><br><span class="line">    <span class="comment"># be called using line = yield from readline(sock)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">sock</span>):</span><br><span class="line">        chars = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            c = <span class="keyword">yield</span> sock.recv(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chars.append(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">b'\n'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b''</span>.join(chars)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Echo server using generators</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EchoServer</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, sched</span>):</span><br><span class="line">            self.sched = sched</span><br><span class="line">            sched.new(self.server_loop(addr))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">server_loop</span>(<span class="params">self, addr</span>):</span><br><span class="line">            s = Socket(socket(AF_INET, SOCK_STREAM))</span><br><span class="line"></span><br><span class="line">            s.bind(addr)</span><br><span class="line">            s.listen(<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                c, a = <span class="keyword">yield</span> s.accept()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'Got connection from '</span>, a)</span><br><span class="line">                self.sched.new(self.client_handler(Socket(c)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">client_handler</span>(<span class="params">self, client</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                line = <span class="keyword">yield</span> <span class="keyword">from</span> readline(client)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                line = <span class="string">b'GOT:'</span> + line</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'line: '</span>, line)</span><br><span class="line">                <span class="keyword">while</span> line:</span><br><span class="line">                    nsent = <span class="keyword">yield</span> client.send(line)</span><br><span class="line">                    line = line[nsent:]</span><br><span class="line">            client.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Client closed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sched = Scheduler()</span><br><span class="line">    EchoServer((<span class="string">''</span>, <span class="number">16000</span>), sched)</span><br><span class="line">    sched.run()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h3><p>上面代码总共分为以下几部分， 分别定义了任务调度器， 任务调度器调度的任务格式（事先定义了<code>YieldEvent</code>接口， 后续有3个实现类）， 简易的echo服务器。 </p><p>上面几个模块， 接下来跟随代码的启动来一一分析。</p><h4 id="框架启动"><a href="#框架启动" class="headerlink" title="框架启动"></a>框架启动</h4><p>main函数里首先定义了一个核心的任务调度器 <code>    sched = Scheduler()</code>。</p><p>这个任务调度器初始化了几个核心组件。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._numtasks = <span class="number">0</span>  <span class="comment"># Total num of tasks， 调度器中的总任务数</span></span><br><span class="line">        self._ready = deque()  <span class="comment"># Tasks ready to run ， 已经就绪的任务， 放在双端队列中</span></span><br><span class="line">        self._read_waiting = {}  <span class="comment"># Tasks waiting to read， 准备读的任务</span></span><br><span class="line">        self._write_waiting = {}  <span class="comment"># Tasks waiting to write， 准备写的任务</span></span><br></pre></td></tr></tbody></table></figure><p>然后通过<code> EchoServer(('', 16000), sched)</code>定义了一个应用服务器, 这里面只做了两个操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr, sched: Scheduler</span>):</span><br><span class="line">    self.sched = sched  // 绑定刚刚的调度器，</span><br><span class="line">    sched.new(self.server_loop(addr))  // 创建一个就绪任务到调度器中</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">self, task</span>):</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Add a newly started task to the scheduler</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">self._ready.append((task, <span class="literal">None</span>))   // 将已经开始的任务放到就绪队列中</span><br><span class="line">self._numtasks += <span class="number">1</span>  // 调度器中任务数+<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>上面的第一个任务（服务器主循环协程）等到下面再说明。</p><p>最后一行执行的是<code>sched.run()</code>， 通过这行代码调度器正式开始启动。</p><p>接下来分析这个<code>run</code>方法。</p><h4 id="sche-run"><a href="#sche-run" class="headerlink" title="sche.run"></a>sche.run</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Run the task scheduler until there are no tasks</span></span><br><span class="line"><span class="string">        运行任务调度器直到没有任务</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 但存在任务的时候执行循环</span></span><br><span class="line">        <span class="keyword">while</span> self._numtasks:                  <span class="comment"># 1</span></span><br><span class="line">            <span class="comment"># 有准备运行的任务</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._ready:                <span class="comment"># 2</span></span><br><span class="line">                <span class="comment"># 执行iopoll的</span></span><br><span class="line">                self._iopoll()                 <span class="comment"># 3</span></span><br><span class="line">            task, msg = self._ready.popleft()  <span class="comment"># 4</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Run the coroutine to the next yield</span></span><br><span class="line">                <span class="comment"># 运行协程直到下一个yield</span></span><br><span class="line">                r = task.send(msg)             <span class="comment"># 5</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(r, YieldEvent):</span><br><span class="line">                    r.handle_yield(self, task) <span class="comment"># 6</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> RuntimeError(<span class="string">'unrecognized yield event'</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                self._numtasks -= <span class="number">1</span>            <span class="comment"># 7</span></span><br></pre></td></tr></tbody></table></figure><p>从代码结构看出来， 调度器是通过循环的方式， 循环的执行自己已经就绪的任务， 当没有就绪任务的时候， 就去执行IO循环。</p><p>接下来模拟程序运行的过程。</p><h6 id="第一轮主循环"><a href="#第一轮主循环" class="headerlink" title="第一轮主循环"></a>第一轮主循环</h6><p>从 #1处看出， 调度器是根据内部可以执行的任务数量来进行判断的， 当内部任务有任务时， 循环就不会结束， 这就是网络框架的主循环。</p><h6 id="判断是否有可以执行的任务"><a href="#判断是否有可以执行的任务" class="headerlink" title="判断是否有可以执行的任务"></a>判断是否有可以执行的任务</h6><p>起初自己的任务队列中是有值的， 在初始化过程中添加了一个<code>(server_loop(), None)</code>的任务到队列中。</p><h6 id="取出可以执行的任务"><a href="#取出可以执行的任务" class="headerlink" title="取出可以执行的任务"></a>取出可以执行的任务</h6><p>#4 这步取出协程任务本身和msg消息， 相当于解码了上面添加的<code>(server_loop(), None)</code>。 这里也是取出了任务队列中唯一的任务。</p><h6 id="启动生成器"><a href="#启动生成器" class="headerlink" title="启动生成器"></a>启动生成器</h6><p><code>server_loop()</code>本身是一个生成器， 在这里也可以称之为协程。他本身并未启动， 需要通过当前的主循环来驱动它执行。 #5 步操作就是启动这个生成器， 相当于<code>server_loop().send(None)</code>， 这是Python的基础语法， 会执行到生成器的第一处yield， 并返回第一个yield值（<code>s.accept()</code>）。</p><p>下面是这个server_loop生成器的内容</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server_loop</span>(<span class="params">self, addr</span>):</span><br><span class="line">    s = Socket(socket(AF_INET, SOCK_STREAM))</span><br><span class="line"></span><br><span class="line">    s.bind(addr)</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c, a = <span class="keyword">yield</span> s.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Got connection from '</span>, a)</span><br><span class="line">        self.sched.new(self.client_handler(Socket(c)))</span><br></pre></td></tr></tbody></table></figure><p>上面 #5 步 r的值就是上面<code>s.accpet()</code>返回的东西. 下面是这个Socket客户端的内部结构</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wrapper around a socket object for use with yield</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self._sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, maxbytes</span>):</span><br><span class="line">        <span class="keyword">return</span> ReadSocket(self._sock, maxbytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> WriteSocket(self._sock, data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accept</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AcceptSocket(self._sock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._sock, name)</span><br></pre></td></tr></tbody></table></figure><p>可以看到其实<code>s.accept()</code>实际上就是一个 AcceptSocket()客户端。 </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AcceptSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        r = self.sock.accept()</span><br><span class="line">        sched.add_ready(task, r)</span><br></pre></td></tr></tbody></table></figure><p>AcceptSocket客户端初始化并没有做任何事， 只是把服务端的socket对象绑定上了。 </p><h6 id="调用handle-yield方法"><a href="#调用handle-yield方法" class="headerlink" title="调用handle_yield方法"></a>调用handle_yield方法</h6><p>这个网络框架规定任务调度器只会执行<code>YieldEvent</code>类型的任务。 而<code>YieldEvent</code>类规定了2个基础接口。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This class represents a generic yield event in the scheduler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldEvent</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p><code>handle_yield</code>方法会在主循环中被调用，<code>handle_resume </code>会被<code>_iopoll</code>方法里面的副循环调用。</p><p>#6步骤执行了<code>AcceptSocket</code>实例对象的<code>handle_yield</code>方法， 它往调度器内部放入了sched._read_wait(self.sock.fileno(), self, task)</p><p>这里可以简单的看一下调度器内部的添加方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_ready</span>(<span class="params">self, task, msg=<span class="literal">None</span></span>):</span><br><span class="line">       <span class="string">'''</span></span><br><span class="line"><span class="string">       Append an already started task to the ready queue.</span></span><br><span class="line"><span class="string">       msg is what to send into the task when it resumes.</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">       self._ready.append((task, msg))</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Add a task to the reading set</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">_read_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">       self._read_waiting[fileno] = (evt, task)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># Add a task to the write set</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">_write_wait</span>(<span class="params">self, fileno, evt, task</span>):</span><br><span class="line">       self._write_waiting[fileno] = (evt, task)</span><br></pre></td></tr></tbody></table></figure><p>这里可以看到在任务调度器的_read_waiting字典中放入了{sock.fileno()： （AcceptSocket类实例对象, 上面启动了的server_loop生成器）}， 这时候框架实际上是把对客户端的监听让底层的select机制来进行监控， 网络框架不会去管这些， 这才是异步的主要原因。 </p><p>现在第一轮主循环进行完毕。 </p><p>这时候调度器中的状态是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._numtasks       <span class="comment"># = 1，服务器启动时进行了加1</span></span><br><span class="line">self._ready          <span class="comment"># 空</span></span><br><span class="line">self._read_waiting   <span class="comment"># {sock.fileno():(AcceptSocket类实例对象, 上面启动了的server_loop生成器)}，可以托管给select了</span></span><br><span class="line">self._write_waiting  <span class="comment"># 空</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第二轮主循环"><a href="#第二轮主循环" class="headerlink" title="第二轮主循环"></a>第二轮主循环</h6><p>服务器是永久执行的，所以调度器中的任务数永远至少为1， 所以主循环可以认为是无限循环的。 </p><h6 id="判断是否有可以执行的任务-1"><a href="#判断是否有可以执行的任务-1" class="headerlink" title="判断是否有可以执行的任务"></a>判断是否有可以执行的任务</h6><p>现在self._ready队列是空的， 所以去执行 <code>self._iopoll()</code>这个分支的代码。</p><h6 id="IO循环"><a href="#IO循环" class="headerlink" title="IO循环"></a>IO循环</h6><p>iopoll()方法可以暂时想象成tornado中的IO循环， 下面看一下IO循环内部干了写什么。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Poll for I/O events and restart waiting tasks</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_iopoll</span>(<span class="params">self</span>):</span><br><span class="line">    rset, wset, eset = select(self._read_waiting,</span><br><span class="line">                              self._write_waiting, [])</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> rset:</span><br><span class="line">        evt, task = self._read_waiting.pop(r)</span><br><span class="line">        evt.handle_resume(self, task)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> wset:</span><br><span class="line">        evt, task = self._write_waiting.pop(w)</span><br><span class="line">        evt.handle_resume(self, task)</span><br></pre></td></tr></tbody></table></figure><p>select方法是实现IO多路复用的基本方法之一， 这里的意思是把需要监听的读写文件描述符让select模块帮忙监听， 当有读写事件就绪了， select方法就会返回rset和wset， eset是出现异常的集合。</p><p>select默认是阻塞的， 当没有套接字状态发生变化的情况下， 这个方法会一直堵塞。</p><h6 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h6><p>现在假设当有一个客户端请求后， select函数立刻返回， 然后执行下面的<code> evt, task = self._read_waiting.pop(r)</code>语句， evt和task分别是AcceptSocket实例对象和serverLoop生成器对象。</p><p>接下来执行<code> evt.handle_resume(self, task)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">    r = self.sock.accept()</span><br><span class="line">    sched.add_ready(task, r)</span><br></pre></td></tr></tbody></table></figure><p>原本sock.accept()是堵塞的， 现在把这个堵塞时间交由系统提供的select机制来监控， 现在有读事件， 表明accept()方法可以立即返回。 这个r返回的是socket接收到客户端client和客户端的ip，端口信息元组。现在把这个信息重新加入到任务调度器的任务队列中。 </p><p>IO循环执行完毕， 接下来回到主循环， 立即会取出刚刚放入的serverLoop生成器和sock.accept()接收到的信息。</p><p>然后运行#5步， 执行<code>server_loop().send(sock.accept())</code>，server_loop生成器继续运行。</p><p>生成器执行yield之后的代码， 并接收客户端和ip信息</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c, a = <span class="keyword">yield</span> s.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Got connection from '</span>, a)</span><br><span class="line">    self.sched.new(self.client_handler(Socket(c)))</span><br></pre></td></tr></tbody></table></figure><p>执行完之后， 调用调用任务调度器， 添加新的就绪任务， 表明可以等待处理客户端的请求信息了。 </p><p>处理客户端请求又是一个生成器(协程)</p><p>代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">client_handler</span>(<span class="params">self, client</span>):</span><br><span class="line">           <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">               line = <span class="keyword">yield</span> <span class="keyword">from</span> readline(client)</span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">               line = <span class="string">b'GOT:'</span> + line</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">'line: '</span>, line)</span><br><span class="line">               <span class="keyword">while</span> line:</span><br><span class="line">                   nsent = <span class="keyword">yield</span> client.send(line)</span><br><span class="line">                   line = line[nsent:]</span><br><span class="line">           client.close()</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">'Client closed'</span>)</span><br></pre></td></tr></tbody></table></figure><p>现在任务队列里面就有了一个(client_handler(Socket(socket)，None)的信息， 但是对于框架来说， 此时虽然知道有一个请求需要处理，但是并没有直接去处理这个请求， 而是需要重新在调度器空闲的重新去接收新的客户端请求。接下来重新执行<code>AcceptSocket</code>实例对象的<code>handle_yield</code>方法， 然后重复上面之前的操作。</p><p>现在第二轮主循环结束</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._numtasks       <span class="comment"># = 2，一个服务器任务，一个客户端请求处理任务</span></span><br><span class="line">self._ready          <span class="comment"># [(client_handler(Socket(clientSocket)，None)]</span></span><br><span class="line">self._read_waiting   <span class="comment"># {sock.fileno():(AcceptSocket类实例对象, 之前的server_loop生成器)}，可以托管给select了</span></span><br><span class="line">self._write_waiting  <span class="comment"># 空</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第三轮主循环"><a href="#第三轮主循环" class="headerlink" title="第三轮主循环"></a>第三轮主循环</h6><p>任务调度器开始处理第一个客户端的请求， #4 run方法取出的第一个任务是客户端的请求， 即(client_handler(Socket(clientSocket)，None)， 然后启动客户端请求处理生成器。</p><p>客户端的处理也是比较复杂的， 会先执行完readline(client)这个生成器内的内容， 然后才往下执行。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of a function involving generators.  This should</span></span><br><span class="line">    <span class="comment"># be called using line = yield from readline(sock)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">sock</span>):</span><br><span class="line">        chars = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            c = <span class="keyword">yield</span> sock.recv(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            chars.append(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">b'\n'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">b''</span>.join(chars)</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个生成器是返回Socket对象的recv(1)的结果， 从下面代码可以看出是返回ReadSocket对象</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock</span>):</span><br><span class="line">        self._sock = sock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, maxbytes</span>):</span><br><span class="line">        <span class="keyword">return</span> ReadSocket(self._sock, maxbytes)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Example implementation of coroutine-based socket I/O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadSocket</span>(<span class="title class_ inherited__">YieldEvent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sock, nbytes</span>):</span><br><span class="line">        self.sock = sock</span><br><span class="line">        self.nbytes = nbytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_yield</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        sched._read_wait(self.sock.fileno(), self, task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">        data = self.sock.recv(self.nbytes)</span><br><span class="line">        sched.add_ready(task, data)   </span><br></pre></td></tr></tbody></table></figure><p>上述代码相当于run方法中#5 r返回的是这个ReadSocket对象， 然后执行#6 的handle_yield方法。 相当于执行<code>ReadSocket(1).handle_yield(sche, client_handler())</code>, 然后把处理连接客户端的socket的文件描述符放到_read_waiting字典中。 </p><p>这样， 第三轮主循环就结束了。 </p><p>当前调度器中的状态如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._numtasks       <span class="comment"># = 2，一个服务器任务，一个客户端请求处理任务</span></span><br><span class="line">self._ready          <span class="comment"># 空</span></span><br><span class="line">self._read_waiting   <span class="comment"># {sock.fileno():(AcceptSocket类实例对象, 之前的server_loop生成器)， sock.fileno():(ReadSocket类实例对象, 启动了的client_handler生成器)}，这里的两个sock.fileno()不是同一个东西， 一个是启动的服务起用来监听客户端连接的socket， 一个是处理第一个客户端连接请求的clientSocket</span></span><br><span class="line">self._write_waiting  <span class="comment"># 空</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第四轮循环"><a href="#第四轮循环" class="headerlink" title="第四轮循环"></a>第四轮循环</h6><p>接下来由于_ready为空， 回去执行IO循环。 由于此时等待读的套接字有两个， 可能有新的请求进来或是客户端发来了信息等待读取， 为了讨论方便， 接下来只考虑只有一个客户端。 那么接下来需要处理客户端的读消息。 那么会去执行   ReadSocket的handle_resume方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_resume</span>(<span class="params">self, sched, task</span>):</span><br><span class="line">    data = self.sock.recv(self.nbytes)</span><br><span class="line">    sched.add_ready(task, data)   </span><br></pre></td></tr></tbody></table></figure><p>这里只读取了一个字节， 然后重新在队列中加入（client_handler， data）数据， 然后在#4步中取出， 然后会在#6步中驱动client_handler这个生成器继续执行， 进而驱动readline这个生成器执行。 client_handler.send(data), 这里的data只有一个字节数据。 最后返回一个新的readsocket对象， 然后主循环执行handle_yield方法， 然后进入IO循环执行handle_resume方法， 继而一直循环， 直至readline生成器执行完成。 </p><h6 id="写事件"><a href="#写事件" class="headerlink" title="写事件"></a>写事件</h6><p>读一行完毕后， 接下来就会去执行发送事件， </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">                   nsent = <span class="keyword">yield</span> client.send(line)</span><br><span class="line">                   line = line[nsent:]</span><br></pre></td></tr></tbody></table></figure><p>每次发送nsent个字节， 这个逻辑和上面的读逻辑基本一样， 就不赘述了。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.zhihu.com/column/tornado">知乎大神的Tornado源码阅读记录</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境： 公司内部使用的web框架是基于tornado封装的， 为了快速熟悉框架与业务， 开始尝试阅读tornado源码， 来加速自己的成长。&lt;/p&gt;
&lt;h2 id=&quot;简化版的协程web框架&quot;&gt;&lt;a href=&quot;#简化版的协程web框架&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="tornado" scheme="http://example.com/categories/tornado/"/>
    
    
    <category term="异步" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
</feed>
